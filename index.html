<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- தலைப்பை மாற்றலாம் -->
    <title>Gemini Chat + Mock Test (v9.1 - Vocab Feature)</title> <!-- Version Updated -->
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mime-types/2.1.35/mime-types.min.js"></script> <!-- Added for Mime Type lookup -->


    <style>
        /* --- Styles (v9.0 - Bilingual & Edit Included - No changes needed here for vocab) --- */
        :root { /* ... Theme Variables ... */
             --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --sidebar-width: 260px; --message-font-size-base: 1rem;
            /* LIGHT */ --sidebar-bg: #f7f7f7; --main-bg: #ffffff; --input-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #2c2c2c; --text-secondary: #5f5f5f; --text-placeholder: #999999; --accent-color: #d97a7a; --user-message-bg: #cce0ff; --user-message-text: #1c1c1c; --ai-message-bg: #f0f0f0; --ai-message-text: #2c2c2c; --button-bg: #f0f0f0; --button-hover-bg: #e0e0e0; --active-item-bg: #e0e0e0; --code-bg: #e8e8e8; --scrollbar-thumb: #ccc; --scrollbar-thumb-hover: #bbb; --app-outer-bg: #e8e8e8; --send-button-bg: var(--accent-color); --send-button-hover-bg: #c76b6b; --send-button-text: #ffffff; --error-bg: #ffebee; --error-text: #c62828; --error-border: #ef9a9a; --message-font-size: var(--message-font-size-base); --delete-button-color: #aaa; --delete-button-hover-color: #dc3545; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color);
            /* Vocab Style */ --vocab-entry-border: 1px solid var(--border-color); --vocab-entry-bg: var(--main-bg); --vocab-word-color: var(--accent-color); --vocab-meaning-color: var(--text-secondary); --vocab-example-label-color: var(--text-secondary); --vocab-image-max-width: 250px; --vocab-image-border-radius: 8px;
        }
        body.dark-theme { /* DARK */ --sidebar-bg: #2a2a2e; --main-bg: #1e1e1e; --input-bg: #2a2a2e; --border-color: #404040; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --text-placeholder: #777777; --accent-color: #e58b8b; --user-message-bg: #3a4a6b; --user-message-text: #e8e8e8; --ai-message-bg: #333333; --ai-message-text: #e0e0e0; --button-bg: #404040; --button-hover-bg: #505050; --active-item-bg: #454545; --code-bg: #2c2c2e; --scrollbar-thumb: #555; --scrollbar-thumb-hover: #666; --app-outer-bg: #121212; --send-button-bg: var(--accent-color); --send-button-hover-bg: #f09f9f; --send-button-text: #1e1e1e; --error-bg: #5c2b2b; --error-text: #ffcdd2; --error-border: #8c4343; --delete-button-color: #666; --delete-button-hover-color: #f09f9f; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color);
            /* Vocab Style Dark */ --vocab-entry-border: 1px solid var(--border-color); --vocab-entry-bg: var(--button-bg); --vocab-word-color: var(--accent-color); --vocab-meaning-color: var(--text-secondary); --vocab-example-label-color: var(--text-secondary);
        }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--app-outer-bg); color: var(--text-primary); font-size: 15px; transition: background-color 0.3s ease, color 0.3s ease; }

        /* --- Layout & Structure --- */
        .app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; } .app-container.hidden { display: none; }
        .sidebar { width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 15px 0; box-sizing: border-box; flex-shrink: 0; transition: background-color 0.3s ease, border-color 0.3s ease, width 0.3s ease; }
        .main-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }
        .main-content, .review-view { display: none; flex-direction: column; background-color: var(--main-bg); height: 100%; width: 100%; overflow: hidden; transition: background-color 0.3s ease; }
        .main-content.active, .review-view.active { display: flex; }
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 30px 10% 20px; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; width: 80%; }
        .input-container { padding: 20px 10%; border-top: 1px solid var(--border-color); background-color: var(--input-bg); max-width: 800px; margin: 0 auto; width: 80%; transition: background-color 0.3s ease, border-color 0.3s ease; display: none; /* Initially hidden until login */ }

        /* --- Sidebar Elements --- */
         .sidebar-header { padding: 10px 20px; font-size: 1.1em; font-weight: 600; color: var(--text-primary); }
         .sidebar-section { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; margin-top: 10px; }
         .sidebar-section-title { padding: 5px 20px; font-size: 0.85em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; flex-shrink: 0; }

         /* --- All Tests Section Styles --- */
         #all-tests-section { border-bottom: 1px solid var(--border-color); margin-bottom: 10px; padding-bottom: 10px; flex-shrink: 0; display: flex; flex-direction: column; max-height: 40%; display: none; }
         #all-tests-section.visible { display: flex; }
         #test-search-input { width: calc(100% - 40px); padding: 8px 10px; margin: 5px 15px 10px 15px; border: 1px solid var(--input-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 6px; font-size: 0.9em; box-sizing: border-box; }
         #test-search-input:focus { outline: none; border-color: var(--input-focus-border-color); }
         #all-tests-list { overflow-y: auto; padding: 0 15px; flex-grow: 1; }
         #all-tests-list::-webkit-scrollbar { width: 6px; } #all-tests-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} #all-tests-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .test-list-item { padding: 8px 10px; margin-bottom: 5px; border-radius: 6px; background-color: var(--button-bg); cursor: default; transition: background-color 0.2s ease; display: flex; flex-direction: column; gap: 5px; border: 1px solid var(--border-color); }
         .test-list-item.hidden-by-search { display: none; }
         .test-list-item .no-search-results { padding:10px;color:var(--text-secondary);font-size:0.9em; }
         .test-item-info { font-size: 0.9em; color: var(--text-primary); position: relative; padding-right: 50px; /* Space for icons */ }
         .test-item-title { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
         .test-item-details { font-size: 0.8em; color: var(--text-secondary); }
         .test-item-actions { display: flex; justify-content: flex-start; gap: 8px; }
         .test-item-actions button, .test-item-actions select { background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 4px 8px; font-size: 0.8em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; }
         .test-item-actions button:hover, .test-item-actions select:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .test-item-actions select:disabled { opacity: 0.6; cursor: not-allowed; }
        /* --- Styles for Edit/Delete Test Icons --- */
        .test-item-controls { position: absolute; right: 5px; top: 0; display: flex; gap: 5px; }
        .test-item-controls button { background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.1em; padding: 0 3px; line-height: 1; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
        .test-item-controls button:hover { opacity: 1; color: var(--delete-button-hover-color); }
        .test-item-edit-mode { display: flex; align-items: center; } /* Container for input + buttons */
        .test-item-edit-mode input[type="text"] { flex-grow: 1; padding: 2px 4px; margin-right: 5px; border: 1px solid var(--input-focus-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 3px; font-size: 0.95em; }
        .test-item-edit-mode button { font-size: 0.9em; padding: 2px 5px; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 3px; cursor: pointer; margin-left: 3px; }
        .test-item-edit-mode button:hover { background-color: var(--button-hover-bg); }
         /* --- End All Tests Section Styles --- */

         .start-chat-button { display: flex; align-items: center; gap: 8px; background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 10px 15px; margin: 0 15px 10px 15px; font-size: 0.95em; font-weight: 500; cursor: pointer; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
         .start-chat-button:hover { background-color: var(--button-hover-bg); } .start-chat-button svg { fill: currentColor; width: 16px; height: 16px; }
         .start-chat-button:disabled { opacity: 0.6; cursor: not-allowed; }

         .chat-list { overflow-y: auto; padding: 0 15px; margin-bottom: 10px; flex-grow: 1; }
         .chat-list::-webkit-scrollbar { width: 6px; } .chat-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} .chat-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .chat-list-item { padding: 8px 30px 8px 10px; margin-bottom: 4px; border-radius: 6px; font-size: 0.9em; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: background-color 0.2s ease, color 0.2s ease; position: relative; }
         .chat-list-item:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .chat-list-item.active { background-color: var(--active-item-bg); color: var(--text-primary); font-weight: 500; }
         .delete-chat-button { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.3em; line-height: 1; padding: 0; display: none; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
         .chat-list-item:hover .delete-chat-button { display: block; }
         .delete-chat-button:hover { color: var(--delete-button-hover-color); opacity: 1; }

         .sidebar-footer { border-top: 1px solid var(--border-color); padding: 10px 15px; transition: border-color 0.3s ease; flex-shrink: 0; }
         .sidebar-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
         .text-size-controls span, .theme-toggle span { font-size: 0.85em; color: var(--text-secondary); }
         .text-size-buttons button, .theme-toggle button { background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 2px 8px; margin-left: 5px; cursor: pointer; font-size: 1.1em; line-height: 1; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
         .text-size-buttons button:hover, .theme-toggle button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .text-size-buttons button:disabled, .theme-toggle button:disabled { opacity: 0.6; cursor: not-allowed; }
         .account-info { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
         .account-avatar { width: 30px; height: 30px; border-radius: 50%; background-color: #6c757d; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; }
         .account-details { overflow: hidden; }
         .account-email { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
         .account-plan { font-size: 0.85em; color: var(--text-secondary); }
         #auth-controls { margin-top: 15px; text-align: center; }
         #auth-controls button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
         #auth-controls button:hover { background-color: var(--button-hover-bg); }
         #logout-btn { display: none; }

        /* --- Chat Area Elements --- */
        .greeting { font-size: 1.8em; font-weight: 600; margin-bottom: 40px; color: var(--text-primary); } .greeting .asterisk { color: var(--accent-color); font-size: 1.2em; margin-right: 5px; display: inline-block; vertical-align: middle; }
        .message { padding: 12px 18px; border-radius: 18px; max-width: 80%; word-wrap: break-word; line-height: 1.6; margin-bottom: 15px; font-size: var(--message-font-size); transition: background-color 0.3s ease, color 0.3s ease; }
        .user-message { background-color: var(--user-message-bg); color: var(--user-message-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--ai-message-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        .ai-message strong { font-weight: 600; } .ai-message em { font-style: italic; }
        .ai-message pre { background-color: var(--code-bg); color: var(--text-primary); padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; transition: background-color 0.3s ease, color 0.3s ease; }
        .ai-message code { font-family: monospace; background-color: var(--code-bg); color: var(--text-primary); padding: 2px 4px; border-radius: 3px; transition: background-color 0.3s ease, color 0.3s ease;}
        .ai-message pre code { background-color: transparent; padding: 0; }
        .ai-message.thinking { background-color: transparent; color: var(--text-secondary); font-style: italic; }
        .error-message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); align-self: flex-start; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;}
        .info-message { text-align: center; color: var(--text-secondary); padding: 50px 20px; font-style: italic; }
        .message mjx-container { color: inherit !important; font-size: inherit !important; }

        /* --- Vocab Styles --- */
        .vocab-entry {
            border: var(--vocab-entry-border);
            background-color: var(--vocab-entry-bg);
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px; /* Space from previous text */
            margin-bottom: 10px; /* Space below entry */
        }
        .vocab-entry ol {
            padding-left: 20px; /* Indent list */
            margin: 0;
        }
        .vocab-entry li {
            margin-bottom: 15px; /* Space between items */
        }
         .vocab-entry li:last-child {
            margin-bottom: 0;
        }
        .vocab-word {
            font-weight: bold;
            font-size: 1.1em;
            color: var(--vocab-word-color);
            display: block; /* Ensure word is on its own line */
            margin-bottom: 3px;
        }
        .vocab-meaning {
            font-style: italic;
            color: var(--vocab-meaning-color);
            display: block;
            margin-bottom: 8px;
        }
        .vocab-example-label {
            font-weight: 500;
            font-size: 0.9em;
            color: var(--vocab-example-label-color);
            margin-right: 5px;
        }
        .vocab-example {
            font-size: 0.95em;
            display: block; /* Ensure examples are on new lines */
            margin-bottom: 5px;
            line-height: 1.5;
        }
         .vocab-image-container {
            margin-top: 10px;
            text-align: center; /* Center image */
         }
         .vocab-image-container img {
            max-width: var(--vocab-image-max-width);
            height: auto;
            border-radius: var(--vocab-image-border-radius);
            border: 1px solid var(--border-color);
         }
         .vocab-image-container .image-info {
             font-size: 0.8em;
             color: var(--text-secondary);
             margin-top: 5px;
         }


        /* --- Input Area Elements --- */
        .suggestions { display: none; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .suggestion-chip { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 16px; padding: 8px 15px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .suggestion-chip:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .input-box { display: flex; align-items: flex-end; background-color: var(--main-bg); border: 1px solid var(--input-border-color); border-radius: 12px; padding: 5px 5px 5px 15px; position: relative; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .input-box:focus-within { border-color: var(--input-focus-border-color); }
        #user-input { flex-grow: 1; border: none; outline: none; padding: 10px 5px; font-size: 1rem; background-color: transparent; resize: none; min-height: 48px; max-height: 250px; line-height: 1.5; color: var(--text-primary); font-family: var(--font-family); }
        #user-input::placeholder { color: var(--text-placeholder); }
        .mcq-mode-control { display: flex; align-items: center; margin-left: 10px; padding-bottom: 8px; flex-shrink: 0; }
        .mcq-mode-control input[type="checkbox"] { margin-right: 5px; accent-color: var(--accent-color); cursor: pointer;}
        .mcq-mode-control label { font-size: 0.85em; color: var(--text-secondary); cursor: pointer; user-select: none;}
        #send-button { background-color: var(--send-button-bg); color: var(--send-button-text); border: none; border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease; padding: 0; flex-shrink: 0; }
        #send-button:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #send-button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
        #send-button svg { width: 20px; height: 20px; fill: currentColor; }
        .thinking::after { content: ' .'; animation: dots 1s steps(3, end) infinite; display: inline-block; }
        @keyframes dots { 0%, 20% { content: ' .'; } 40% { content: ' ..'; } 60%, 100% { content: ' ...'; } }
         .start-test-button { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 8px 15px; margin-top: 10px; cursor: pointer; font-weight: 500; display: inline-block; transition: background-color 0.2s ease; }
         .start-test-button:hover { background-color: var(--send-button-hover-bg); }

        /* --- Mock Test View Styles --- */
        .mock-test-view { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--main-bg); z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; transition: background-color 0.3s ease; }
        .mock-test-view.active { display: flex; }
        .test-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .test-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); }
        .test-info { display: flex; align-items: center; } /* Align items horizontally */
        .test-info span { margin-left: 15px; font-size: 0.95em; color: var(--text-secondary); }
        /* Style for language toggle button */
        #test-language-toggle, #review-language-toggle {
            margin-left: 15px; padding: 3px 8px; font-size: 0.8em; cursor: pointer;
            background-color: var(--button-bg); border: 1px solid var(--border-color);
            color: var(--text-secondary); border-radius: 4px;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        #test-language-toggle:hover, #review-language-toggle:hover {
             background-color: var(--button-hover-bg); color: var(--text-primary);
        }
        .test-content { flex-grow: 1; overflow-y: auto; padding: 10px 20px; }
        .test-question-container { margin-bottom: 25px; }
        .test-question-number { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .test-question { font-size: 1.1em; line-height: 1.5; margin-bottom: 15px; color: var(--text-primary); }
        .test-options label { display: block; margin-bottom: 12px; background-color: var(--button-bg); padding: 12px 15px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; color: var(--text-primary); }
        .test-options label:hover { background-color: var(--button-hover-bg); }
        .test-options input[type="radio"] { margin-right: 10px; accent-color: var(--accent-color); cursor: pointer;}
        .test-navigation { display: flex; justify-content: space-between; padding-top: 15px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; }
        .test-navigation button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px 20px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease; }
        .test-navigation button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        .test-navigation button#submit-test-btn { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color); }
        .test-navigation button#submit-test-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        .test-navigation button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* --- Review View Styles --- */
        .review-view { padding: 20px; box-sizing: border-box; background-color: var(--main-bg); }
        .review-header { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .review-header h2 { margin: 0 0 10px 0; font-size: 1.3em; color: var(--text-primary); }
        .review-summary { display: inline; } /* Allow toggle button next to it */
        .review-summary span { margin-right: 20px; font-size: 1em; color: var(--text-primary); }
        .review-summary .score-correct { color: #28a745; font-weight: bold;} .review-summary .score-incorrect { color: #dc3545; font-weight: bold;} .review-summary .score-skipped { color: #fd7e14; font-weight: bold;}
        .review-filters { margin-top: 10px; /* Add space above filters */ margin-bottom: 15px; }
        .review-filters button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 5px 12px; margin-right: 8px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease, border-color 0.2s ease; }
        .review-filters button:hover { background-color: var(--button-hover-bg); }
        .review-filters button.active-filter { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color);}
        .review-content { flex-grow: 1; overflow-y: auto; padding-right: 10px; }
        .review-item { margin-bottom: 15px; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--button-bg); transition: background-color 0.3s ease, border-color 0.3s ease; }
        .review-item.hidden-by-filter { display: none; }
        .review-item-qnum { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .review-item-question { margin-bottom: 10px; line-height: 1.5; color: var(--text-primary); }
        .review-item-details span { display: block; margin-bottom: 5px; font-size: 0.95em; color: var(--text-primary); }
        .review-item-details .correct-answer { color: #28a745; font-weight: bold; }
        .review-item-details .user-answer-correct { color: #28a745; } .review-item-details .user-answer-incorrect { color: #dc3545; text-decoration: line-through; } .review-item-details .user-answer-skipped { color: #fd7e14; font-style: italic; }
        /* Style for explanation in review */
        .review-item-explanation { margin-top: 8px; font-size: 0.9em; color: var(--text-secondary); border-left: 3px solid var(--border-color); padding-left: 8px; line-height: 1.4; }
        .review-footer { text-align: center; padding-top: 20px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #exit-review-btn, #save-review-btn { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 10px 25px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; display: none; }
        #exit-review-btn:hover, #save-review-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #save-review-btn { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        #save-review-btn:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        #save-review-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #cccccc; border-color: #aaaaaa; }

        /* --- Responsive Design (Mobile) --- */
        @media (max-width: 768px) {
            :root { --sidebar-width: 200px; }
            .sidebar { padding: 10px 0; /* Adjusted */ }
            .main-container { /* Adjusted */ }
            .chat-area, .input-container { width: 95%; padding-left: 2.5%; padding-right: 2.5%; max-width: none; }
            .chat-area { padding-top: 15px; padding-bottom: 10px; }
            .input-container { padding-top: 10px; padding-bottom: 10px; }
            .message { max-width: 90%; font-size: calc(var(--message-font-size) * 0.95); }
            .greeting { font-size: 1.5em; margin-bottom: 20px; }
            .suggestions { gap: 5px; margin-bottom: 10px; }
            .suggestion-chip { padding: 6px 10px; font-size: 0.85em; }
            .input-box { padding: 5px 5px 5px 10px; }
            #user-input { min-height: 40px; font-size: 0.95rem; }
            #send-button { width: 32px; height: 32px; }
            .mcq-mode-control label { font-size: 0.8em; }
             /* Vocab Mobile */
            .vocab-image-container img { max-width: 200px; }

            /* Sidebar elements adjustments */
            .sidebar-header { font-size: 1em; padding: 8px 15px; }
            .sidebar-section-title { padding: 5px 15px; font-size: 0.8em;}
            #test-search-input { margin: 5px 10px 8px 10px; width: calc(100% - 20px); }
            #all-tests-list, .chat-list { padding: 0 10px; }
            .test-list-item, .chat-list-item { padding: 6px 8px; font-size: 0.85em;}
            .chat-list-item { padding-right: 25px; }
            .start-chat-button { padding: 8px 12px; margin: 0 10px 8px 10px; font-size: 0.9em; }
            .sidebar-footer { padding: 8px 10px;}
            .text-size-buttons button, .theme-toggle button { padding: 1px 6px; font-size: 1em;}
            .account-info { font-size: 0.85em; gap: 8px;}
            .account-avatar { width: 25px; height: 25px;}
            .test-item-info { padding-right: 45px; } /* Adjust space for icons on mobile */
            .test-item-controls button { font-size: 1em; }
            .test-item-edit-mode input[type="text"] { font-size: 0.9em; }
            .test-item-edit-mode button { font-size: 0.85em; }
            /* Test/Review View Adjustments */
            .mock-test-view, .review-view { padding: 10px; }
            .test-header, .review-header { margin-bottom: 15px; padding-bottom: 8px; flex-direction: column; align-items: flex-start; }
            .test-header h2, .review-header h2 { font-size: 1.1em; margin-bottom: 5px;}
            .test-info, .review-summary { margin-bottom: 5px; } /* Space below info/summary */
            .test-info span, .review-summary span { margin-left: 0; margin-right: 10px; font-size: 0.9em; display: inline-block; margin-bottom: 3px;}
            #test-language-toggle, #review-language-toggle { margin-left: 0; margin-top: 5px; font-size: 0.75em;} /* Adjust toggle on mobile */
            .test-content, .review-content { padding: 5px; }
            .test-question, .review-item-question { font-size: 1em; }
            .test-options label, .review-item { padding: 10px; font-size: 0.95em;}
            .review-filters { margin-top: 5px; } /* Adjust filter margin */
            .review-filters button { padding: 4px 8px; font-size: 0.85em; margin-right: 5px;}
            .test-navigation, .review-footer { padding-top: 10px; }
            .test-navigation button, #exit-review-btn, #save-review-btn { padding: 8px 15px; font-size: 0.9em; }
        }

    </style>
</head>
<body>

    <div class="app-container" id="app-container">
        <div class="sidebar">
            <div class="sidebar-header">Gemini Chat</div>

            <!-- == "All Tests" Section == -->
            <div id="all-tests-section">
                <div class="sidebar-section-title">All Tests</div>
                <input type="search" id="test-search-input" placeholder="Search tests..." disabled>
                <div class="all-tests-list" id="all-tests-list">
                     <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div>
                </div>
            </div>
            <!-- == End "All Tests" Section == -->

            <!-- Existing sections wrapped -->
            <div class="sidebar-section">
                <button class="start-chat-button" id="start-chat" disabled> <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>
                     Start new chat
                </button>
                <div class="sidebar-section-title">Chats</div>
                <div class="chat-list" id="chat-list">
                     <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>
                </div>
            </div>

            <div class="sidebar-footer">
                 <div class="sidebar-controls">
                     <div class="text-size-controls">
                         <span>Text Size</span>
                         <div class="text-size-buttons">
                             <button id="decrease-text-size" title="Decrease text size" disabled>-</button> <button id="increase-text-size" title="Increase text size" disabled>+</button> </div>
                     </div>
                     <div class="theme-toggle">
                         <button id="theme-toggle-button" title="Toggle Theme" disabled>☀️</button> </div>
                 </div>
                  <div id="auth-controls">
                      <button id="login-google-btn">Login with Google</button>
                      <button id="logout-btn" style="display: none;">Logout</button>
                  </div>
                  <div class="account-info">
                      <div class="account-avatar" id="account-avatar">?</div>
                      <div class="account-details">
                          <div class="account-email" id="account-email">Not logged in</div>
                          <div class="account-plan" id="account-plan"></div>
                      </div>
                  </div>
            </div>
        </div>

        <div class="main-container">
            <div class="main-content active" id="main-content-chat">
                 <div class="chat-area" id="chat-area">
                     <!-- Chat messages will be loaded here -->
                 </div>
                 <div class="input-container" id="input-container">
                     <div class="suggestions" id="suggestions">
                          <button class="suggestion-chip" data-prompt="5 questions about US History">5 Qs US History (Check MCQ)</button>
                          <button class="suggestion-chip" data-prompt="What is recursion?">Recursion?</button>
                          <button class="suggestion-chip" data-prompt="Explain $\lim_{x\to 0} \frac{\sin x}{x} = 1$">Limit sin(x)/x ?</button>
                          <button class="suggestion-chip" data-prompt="Give synonyms for 'happy'">Synonyms for 'happy'?</button> <!-- Added Vocab Suggestion -->
                     </div>
                    <div class="input-box">
                        <textarea id="user-input" placeholder="Enter prompt (e.g., 'synonym for quick', 'idiom break a leg')" rows="1"></textarea> <!-- Updated Placeholder -->
                        <div class="mcq-mode-control"> <input type="checkbox" id="mcq-mode-checkbox" title="Check to generate MCQs based on your prompt"> <label for="mcq-mode-checkbox">MCQs?</label> </div>
                        <button id="send-button" title="Send message" disabled> <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </button>
                    </div>
                 </div>
            </div>
            <div class="review-view" id="review-view">
                 <div class="review-header">
                     <h2 id="review-title">Test Review</h2>
                     <div> <!-- Wrapper for summary and toggle -->
                         <div class="review-summary" id="review-summary"></div>
                         <!-- Add Language Toggle Button -->
                         <button id="review-language-toggle" style="margin-left: 15px; padding: 3px 8px; font-size: 0.8em; vertical-align: middle;">தமிழ்</button>
                     </div>
                     <div class="review-filters" id="review-filters" style="display: none;">
                         <button data-filter="all" class="active-filter">All</button>
                         <button data-filter="incorrect">Incorrect</button>
                         <button data-filter="skipped">Skipped</button>
                     </div>
                 </div>
                 <div class="review-content" id="review-content"></div>
                 <div class="review-footer">
                     <button id="save-review-btn">Save Review</button>
                     <button id="exit-review-btn">Back</button>
                 </div>
              </div>
        </div>
    </div>

    <div class="mock-test-view" id="mock-test-view">
         <div class="test-header">
            <h2 id="test-title">Mock Test</h2>
            <div class="test-info">
                <span id="question-counter">Q: 1 / N</span>
                <span id="test-timer">Time: 00:00</span>
                <!-- Add Language Toggle Button -->
                <button id="test-language-toggle" style="margin-left: 15px; padding: 3px 8px; font-size: 0.8em;">தமிழ்</button>
            </div>
         </div>
         <div class="test-content">
            <div class="test-question-container">
                <div class="test-question-number" id="test-question-number"></div>
                <div class="test-question" id="test-question"></div>
                <div class="test-options" id="test-options"></div>
            </div>
         </div>
         <div class="test-navigation">
            <button id="prev-question-btn" disabled>Previous</button>
            <button id="next-question-btn">Next</button>
            <button id="submit-test-btn">Submit Test</button>
         </div>
    </div>


    <script>
        // --- Firebase Config ---
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // !!! பாதுகாப்பு எச்சரிக்கை / SECURITY WARNING !!!
        // This firebaseConfig (especially apiKey) is insecure because it was shared.
        // After testing, delete/restrict this API key in Firebase Console and use a new one here.
        // DO NOT DEPLOY WITH THIS SHARED KEY. USE A SERVER-SIDE SOLUTION (e.g., Cloud Functions)
        // TO HIDE YOUR API KEY AND MAKE API CALLS SECURELY.
        // இந்த firebaseConfig (குறிப்பாக apiKey) பகிரப்பட்டதால் பாதுகாப்பற்றது.
        // சோதனைக்குப் பிறகு, Firebase Console-ல் இந்த API key-ஐ நீக்கவும்/கட்டுப்படுத்தவும் மற்றும் இங்கே புதியதைப் பயன்படுத்தவும்.
        // இந்த பகிரப்பட்ட KEY உடன் DEPLOY செய்ய வேண்டாம். உங்கள் API KEY-ஐ மறைக்க மற்றும் API அழைப்புகளைப்
        // பாதுகாப்பாகச் செய்ய SERVER-SIDE SOLUTION-ஐ (எ.கா., Cloud Functions) பயன்படுத்தவும்.
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        const firebaseConfig = {
          apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58", // <- பகிரப்பட்ட, பாதுகாப்பற்ற Key / SHARED, INSECURE KEY - REPLACE ME
          authDomain: "krish-c5db8.firebaseapp.com",
          projectId: "krish-c5db8",
          storageBucket: "krish-c5db8.appspot.com",
          messagingSenderId: "217175257890",
          appId: "1:217175257890:web:209f0f290eabab6b1fab7b",
          measurementId: "G-97SHYGL2J4"
        };

        // --- Initialize Firebase ---
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const db = firebase.firestore();

        // --- DOM Elements ---
        const appContainer = document.getElementById('app-container');
        const chatArea = document.getElementById('chat-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const suggestionsContainer = document.getElementById('suggestions');
        const startChatButton = document.getElementById('start-chat');
        const chatListContainer = document.getElementById('chat-list');
        const allTestsSection = document.getElementById('all-tests-section');
        const testSearchInput = document.getElementById('test-search-input');
        const allTestsListContainer = document.getElementById('all-tests-list');
        const accountEmail = document.getElementById('account-email');
        const accountAvatar = document.getElementById('account-avatar');
        const accountPlan = document.getElementById('account-plan');
        const decreaseTextBtn = document.getElementById('decrease-text-size');
        const increaseTextBtn = document.getElementById('increase-text-size');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const mainContainer = document.querySelector('.main-container');
        const chatView = document.getElementById('main-content-chat');
        const testView = document.getElementById('mock-test-view');
        const reviewView = document.getElementById('review-view');
        const inputContainer = document.getElementById('input-container');
        const mcqModeCheckbox = document.getElementById('mcq-mode-checkbox');
        // Auth buttons
        const loginBtn = document.getElementById('login-google-btn');
        const logoutBtn = document.getElementById('logout-btn');
        // Test elements
        const testTitle = document.getElementById('test-title');
        const questionCounter = document.getElementById('question-counter');
        const testTimer = document.getElementById('test-timer');
        const testQuestionNumber = document.getElementById('test-question-number');
        const testQuestion = document.getElementById('test-question');
        const testOptionsContainer = document.getElementById('test-options');
        const prevQuestionBtn = document.getElementById('prev-question-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const submitTestBtn = document.getElementById('submit-test-btn');
        const testLanguageToggle = document.getElementById('test-language-toggle'); // New
        // Review elements
        const reviewTitle = document.getElementById('review-title');
        const reviewSummary = document.getElementById('review-summary');
        const reviewContent = document.getElementById('review-content');
        const exitReviewBtn = document.getElementById('exit-review-btn');
        const reviewFilters = document.getElementById('review-filters');
        const saveReviewBtn = document.getElementById('save-review-btn');
        const reviewLanguageToggle = document.getElementById('review-language-toggle'); // New

        // --- Config & Constants ---
        const TEXT_MODEL_NAME="gemini-2.5-pro-exp-03-25"; // Renamed for clarity
        const VOCAB_MODEL_NAME="gemini-2.0-flash-exp-image-generation"; // Added for vocab requests
        const API_URL_BASE=`https://generativelanguage.googleapis.com/v1beta/models/`; // Base URL, model name will be appended
        const STORAGE_KEY_API_KEY='geminiApiKey_insecureDemo'; // மீண்டும், இது பாதுகாப்பற்றது
        const NEW_CHAT_TITLE="(New Chat)";
        const TEXT_SIZE_STEP=0.1;
        const MIN_TEXT_SIZE_MULTIPLIER=0.7;
        const MAX_TEXT_SIZE_MULTIPLIER=1.5;
        const LIGHT_THEME_ICON='☀️';
        const DARK_THEME_ICON='🌙';
        const DELETE_ICON = '×'; // Chat delete icon
        const EDIT_TEST_ICON = '✏️';
        const DELETE_TEST_ICON = '🗑️';
        // Keywords to trigger vocab mode (lowercase)
        const VOCAB_KEYWORDS = ['synonym', 'antonym', 'syno', 'anto', 'idiom', 'ows', 'one word substitution', 'meaning of', 'definition of', 'vocab'];


        // --- State Variables ---
        let API_KEY='';
        let currentUser = null;
        let activeChatId = null;
        let currentChatHistory=[];
        let currentTextSizeMultiplier=1.0;
        let currentTheme='light';
        let isTestMode=false;
        let isReviewMode=false;
        let currentTestMCQs=[];
        let currentQuestionIndex=0;
        let userAnswers=[];
        let testStartTime=null;
        let testTimerInterval=null;
        let reviewResultsCache = null;
        let cameFromAllTestsList = false;
        let activeChatListener = null;
        let chatListListener = null;
        let testListListener = null;
        let isDeletingChat = false;
        let allSavedTestsData = [];
        let currentTestLanguage = 'en'; // 'en' or 'ta' - for active test
        let currentReviewLanguage = 'en'; // 'en' or 'ta' - for review view

        // --- Initialization ---
        initializeApp();

        // --- Event Listeners ---
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('input', autoGrowTextarea);
        userInput.addEventListener('keydown', handleInputKeydown);
        suggestionsContainer.addEventListener('click', handleSuggestionClick);
        startChatButton.addEventListener('click', createNewChat);
        chatListContainer.addEventListener('click', handleChatListClick);
        allTestsListContainer.addEventListener('click', handleAllTestsListClick); // Handles View, Edit, Delete test
        testSearchInput.addEventListener('input', filterTestsInSidebar);
        decreaseTextBtn.addEventListener('click', () => adjustTextSize(-TEXT_SIZE_STEP));
        increaseTextBtn.addEventListener('click', () => adjustTextSize(TEXT_SIZE_STEP));
        themeToggleButton.addEventListener('click', toggleTheme);
        // Test listeners
        prevQuestionBtn.addEventListener('click', () => handleTestNavigation('prev'));
        nextQuestionBtn.addEventListener('click', () => handleTestNavigation('next'));
        submitTestBtn.addEventListener('click', submitTest);
        testLanguageToggle.addEventListener('click', toggleTestLanguage); // New
        // Review listeners
        exitReviewBtn.addEventListener('click', exitReview);
        chatArea.addEventListener('click', handleChatAreaClick);
        reviewFilters.addEventListener('click', handleReviewFilterClick);
        saveReviewBtn.addEventListener('click', saveTestReviewToCloud);
        reviewLanguageToggle.addEventListener('click', toggleReviewLanguage); // New
        // Auth listeners
        loginBtn.addEventListener('click', signInWithGoogle);
        logoutBtn.addEventListener('click', signOut);


        // --- Initialization Functions ---
        async function initializeApp() {
            loadGeminiApiKey(); // Load insecurely stored key
            fbAuth.onAuthStateChanged(handleAuthStateChange); // Listen for login/logout
            switchView('chat'); // Start in chat view
            userInput.focus();
        }

        function loadGeminiApiKey() {
             console.warn("!!! SECURITY WARNING / பாதுகாப்பு எச்சரிக்கை !!! Gemini API Key is stored in localStorage. This is highly insecure and only for demonstration. Use a server-side solution (like Cloud Functions) to protect your key in production. / Gemini API Key localStorage-ல் சேமிக்கப்படுகிறது. இது மிகவும் பாதுகாப்பற்றது மற்றும் டெமோவுக்கு மட்டுமே. Production-ல் உங்கள் key-ஐப் பாதுகாக்க server-side solution-ஐ (Cloud Functions போன்றவை) பயன்படுத்தவும்.");
             API_KEY = localStorage.getItem(STORAGE_KEY_API_KEY);
             if(API_KEY){
                 console.log("Loaded insecure API Key from localStorage.");
             }
             else {
                 // Use prompt only if key is missing - less annoying
                 API_KEY=prompt("--- INSECURE DEMO / பாதுகாப்பற்ற டெமோ ---\nPlease enter your Gemini API Key.\nIt will be stored *insecurely* in your browser's localStorage.\nDo NOT use this method in production!\n\nஉங்கள் Gemini API Key-ஐ உள்ளிடவும்.\nஇது உங்கள் உலாவியின் localStorage-ல் *பாதுகாப்பற்ற முறையில்* சேமிக்கப்படும்.\nProduction-ல் இந்த முறையைப் பயன்படுத்த வேண்டாம்!");
                 if(API_KEY){
                     localStorage.setItem(STORAGE_KEY_API_KEY, API_KEY);
                     console.log("Saved insecure API Key to localStorage.");
                 }
                 else {
                     displayError("Gemini API Key is required for this demo. Reload the page to enter it. / இந்த டெமோவிற்கு Gemini API Key தேவை. அதை உள்ளிட பக்கத்தை மீண்டும் ஏற்றவும்.");
                     setLoadingState(true, "API Key Missing");
                 }
             }
             // Enable input/send only if API key is present
             setLoadingState(!API_KEY);
        }

        // --- Authentication Functions ---
        async function signInWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                setLoadingState(true, "Logging in...");
                await fbAuth.signInWithPopup(provider);
                // handleAuthStateChange will take over
            } catch (error) {
                console.error("Google Sign-In Error:", error);
                displayError(`Login failed: ${error.message || 'Unknown error'}`);
                setLoadingState(false);
            }
        }

        async function signOut() {
            try {
                setLoadingState(true, "Logging out...");
                await fbAuth.signOut();
                // handleAuthStateChange will take over
            } catch (error) {
                console.error("Sign Out Error:", error);
                displayError(`Logout failed: ${error.message || 'Unknown error'}`);
                setLoadingState(false);
            }
        }

        function handleAuthStateChange(user) {
            // Cleanup previous state
            if (activeChatListener) { activeChatListener(); activeChatListener = null; }
            if (chatListListener) { chatListListener(); chatListListener = null; }
            if (testListListener) { testListListener(); testListListener = null; }

            chatArea.innerHTML = '';
            chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>'; // Default message
            allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div>'; // Default message
            allTestsSection.classList.remove('visible');
            testSearchInput.value = '';
            testSearchInput.disabled = true;
            activeChatId = null;
            currentChatHistory = [];
            isDeletingChat = false;
            allSavedTestsData = [];

            if (user) {
                // User is logged IN
                currentUser = user;
                console.log("User logged in:", currentUser.uid, currentUser.displayName || currentUser.email);

                loginBtn.style.display = 'none';
                logoutBtn.style.display = 'inline-block';
                accountEmail.textContent = currentUser.email || currentUser.displayName || `User`;
                accountAvatar.textContent = (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase();
                accountPlan.textContent = "Firebase User"; // Placeholder

                // Enable controls
                startChatButton.disabled = false;
                decreaseTextBtn.disabled = false;
                increaseTextBtn.disabled = false;
                themeToggleButton.disabled = false;
                testSearchInput.disabled = false;
                userInput.disabled = false;
                sendButton.disabled = true; // Disabled until a chat is selected/created
                mcqModeCheckbox.disabled = true; // Disabled until a chat is selected/created
                userInput.placeholder = "Select or create a chat";
                inputContainer.style.display = 'block';
                suggestionsContainer.style.display = 'flex';
                allTestsSection.classList.add('visible');


                loadUserSettings(currentUser.uid);
                loadAndListenForChats(currentUser.uid); // Will select/load a chat or show prompt
                loadAndListenForTests(currentUser.uid);

                setLoadingState(false); // Reset loading state after setup

            } else {
                // User is logged OUT
                currentUser = null;
                console.log("User logged out");

                loginBtn.style.display = 'inline-block';
                logoutBtn.style.display = 'none';
                accountEmail.textContent = "Not logged in";
                accountAvatar.textContent = '?';
                accountPlan.textContent = "";

                // Disable controls
                startChatButton.disabled = true;
                decreaseTextBtn.disabled = true;
                increaseTextBtn.disabled = true;
                themeToggleButton.disabled = true;
                testSearchInput.disabled = true;
                userInput.disabled = true;
                sendButton.disabled = true;
                mcqModeCheckbox.disabled = true;
                userInput.placeholder = "Please log in";
                inputContainer.style.display = 'none';
                suggestionsContainer.style.display = 'none';
                allTestsSection.classList.remove('visible');

                renderGreetingOrLoginPrompt(); // Show login prompt in chat area

                // Reset theme/text size to defaults
                currentTheme = 'light'; applyTheme();
                currentTextSizeMultiplier = 1.0; applyTextSize();

                setLoadingState(false);
            }
        }

        function renderGreetingOrLoginPrompt() {
            chatArea.innerHTML = '';
            const greetingElement = document.createElement('div');
            greetingElement.classList.add('greeting');
            if (currentUser) {
                 greetingElement.innerHTML = `<span class="asterisk">*</span>Good day, ${currentUser.displayName || 'User'}!`;
                 chatArea.appendChild(greetingElement);
                 if (!activeChatId) {
                     displayMessage("Select a chat from the sidebar or start a new one.", 'ai');
                 }
            } else {
                greetingElement.innerHTML = `<span class="asterisk">*</span>Welcome!`;
                chatArea.appendChild(greetingElement);
                displayMessage("Please log in using the Google button in the sidebar to start chatting or view your history.", 'ai');
            }
            scrollToBottom(true);
        }


        // --- Settings (Theme/Text Size) ---
        async function loadUserSettings(userId) { /* ... (same as before) ... */
             const userDocRef = db.collection('users').doc(userId);
            try {
                const docSnap = await userDocRef.get();
                if (docSnap.exists) {
                    const settings = docSnap.data();
                    currentTheme = settings.theme || 'light';
                    currentTextSizeMultiplier = settings.textSizeMultiplier || 1.0;
                    console.log("Loaded user settings:", settings);
                } else {
                    console.log("No user settings found, using defaults and saving.");
                    currentTheme = 'light';
                    currentTextSizeMultiplier = 1.0;
                    await saveUserSettings();
                }
            } catch (error) {
                console.error("Error loading user settings:", error);
                currentTheme = 'light';
                currentTextSizeMultiplier = 1.0;
            }
            applyTheme();
            applyTextSize();
         }
        async function saveUserSettings() { /* ... (same as before) ... */
             if (!currentUser) return;
            const userDocRef = db.collection('users').doc(currentUser.uid);
            const settings = {
                theme: currentTheme,
                textSizeMultiplier: currentTextSizeMultiplier
            };
            try {
                await userDocRef.set(settings, { merge: true });
                console.log("User settings saved:", settings);
            } catch (error) {
                console.error("Error saving user settings:", error);
            }
         }
        function applyTheme() { /* ... (same as before) ... */
             if(currentTheme==='dark'){
                document.body.classList.add('dark-theme');
                themeToggleButton.textContent=LIGHT_THEME_ICON;
                themeToggleButton.title="Switch to Light Theme";
            } else {
                document.body.classList.remove('dark-theme');
                themeToggleButton.textContent=DARK_THEME_ICON;
                themeToggleButton.title="Switch to Dark Theme";
            }
         }
        function toggleTheme() { /* ... (same as before) ... */
            if (!currentUser) return;
            currentTheme = (currentTheme === 'light') ? 'dark' : 'light';
            applyTheme();
            saveUserSettings();
        }
        function applyTextSize() { /* ... (same as before) ... */
            const newSize = `calc(var(--message-font-size-base) * ${currentTextSizeMultiplier})`;
            document.documentElement.style.setProperty('--message-font-size', newSize);
            decreaseTextBtn.disabled = !currentUser || currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER;
            increaseTextBtn.disabled = !currentUser || currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER;
            console.log("Applied text size multiplier:", currentTextSizeMultiplier);
        }
        function adjustTextSize(change) { /* ... (same as before) ... */
             if (!currentUser) return;
            let newMultiplier = Math.max(MIN_TEXT_SIZE_MULTIPLIER, Math.min(MAX_TEXT_SIZE_MULTIPLIER, currentTextSizeMultiplier + change));
            newMultiplier = Math.round(newMultiplier * 10) / 10;
            if (newMultiplier !== currentTextSizeMultiplier) {
                currentTextSizeMultiplier = newMultiplier;
                applyTextSize();
                saveUserSettings();
            }
         }

        // --- Chat Storage & Loading (Firestore) ---
        function loadAndListenForChats(userId) { /* ... (same as before, handles selection/loading) ... */
            if (chatListListener) { chatListListener(); chatListListener = null; }

            const chatsRef = db.collection('chats')
                               .where('userId', '==', userId)
                               .orderBy('lastUpdated', 'desc');

            console.log(`Listening for chats for user ${userId}`);
            chatListListener = chatsRef.onSnapshot(snapshot => {
                 if (isDeletingChat) {
                     console.log("Skipping chat list update during delete operation. isDeletingChat =", isDeletingChat);
                     return;
                 }
                console.log("Processing chat list snapshot update. isDeletingChat =", isDeletingChat);

                const chats = [];
                snapshot.forEach(doc => {
                    chats.push({ id: doc.id, ...doc.data() });
                });
                console.log("Received chat list snapshot:", chats.length, "chats");
                renderSidebarChatList(chats); // Update UI

                let chatToLoad = null;
                if (activeChatId && chats.some(c => c.id === activeChatId)) {
                    chatToLoad = activeChatId; // Keep current if it still exists
                } else if (chats.length > 0) {
                    chatToLoad = chats[0].id; // Select newest if current is gone or none was active
                    console.log("Active chat not found or was deleted, selecting newest:", chatToLoad);
                } else {
                    // No chats exist
                    console.log("No chats found for user.");
                    activeChatId = null;
                    if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                    renderGreetingOrLoginPrompt(); // Show greeting/prompt
                    setLoadingState(false);
                    sendButton.disabled = true; // Ensure send is disabled
                    mcqModeCheckbox.disabled = true;
                    userInput.placeholder = "Create a new chat to start";
                }

                 // Switch only if the target chat is different from the current active one
                 if (chatToLoad && chatToLoad !== activeChatId) {
                     console.log("Switching to chat:", chatToLoad);
                     switchChat(chatToLoad); // This handles loading state and focusing
                 } else if (activeChatId) {
                      // Already on the correct chat or no chat to load
                      highlightActiveChatInSidebar(); // Ensure highlight is correct
                      setLoadingState(false); // Ensure loading is off
                      // Enable send if a chat is active
                      sendButton.disabled = !API_KEY;
                      mcqModeCheckbox.disabled = !API_KEY;
                      userInput.placeholder = "Enter prompt (e.g., 'synonym for quick', 'idiom break a leg')"; // Restore placeholder
                 } else {
                     // No chat selected/available
                     setLoadingState(false);
                     userInput.placeholder = "Create a new chat to start"; // Restore placeholder
                 }

            }, error => {
                console.error("Error listening for chats:", error);
                displayError("Could not load your chat list. Please check your connection or try again later.");
                chatListContainer.innerHTML = '<div style="padding:10px;color:var(--error-text);font-size:0.9em;">Error loading chats.</div>';
                setLoadingState(false);
            });
        }

        function renderSidebarChatList(chats) { /* ... (same as before - renders list items with delete button) ... */
            chatListContainer.innerHTML = '';
            if (!currentUser) {
                chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in.</div>';
                return;
            }
            if (chats.length === 0) {
                const infoElement = document.createElement('div');
                infoElement.textContent = "No chats yet. Start one!";
                infoElement.style.cssText = "padding:10px;color:var(--text-secondary);font-size:0.9em;";
                chatListContainer.appendChild(infoElement);
            } else {
                chats.forEach(chatData => {
                    const itemElement = document.createElement('div');
                    itemElement.classList.add('chat-list-item');

                    let title = chatData.title;
                    if (typeof title !== 'string' || !title.trim()) {
                         title = '(Untitled Chat)';
                    }
                    title = title.trim();

                    itemElement.textContent = title;
                    itemElement.dataset.id = chatData.id;
                    itemElement.title = title;

                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('delete-chat-button');
                    deleteBtn.innerHTML = DELETE_ICON; // Use '×'
                    deleteBtn.title = "Delete chat";
                    deleteBtn.dataset.id = chatData.id; // Store ID on button
                    itemElement.appendChild(deleteBtn);

                    chatListContainer.appendChild(itemElement);
                });
            }
            highlightActiveChatInSidebar();
        }

        function highlightActiveChatInSidebar() { /* ... (same as before) ... */
             const items = chatListContainer.querySelectorAll('.chat-list-item');
             items.forEach(item => {
                 item.classList.toggle('active', item.dataset.id === activeChatId);
             });
             // Update loading state based on whether a chat is active
             // setLoadingState(!activeChatId && currentUser); // Maybe too aggressive
        }

        async function createNewChat() { /* ... (same as before) ... */
            if (!currentUser) { displayError("Please log in to create a new chat."); return; }
            setLoadingState(true, "Creating chat...");
            const newChatRef = db.collection('chats').doc();
            const timestamp = firebase.firestore.FieldValue.serverTimestamp();

            try {
                await newChatRef.set({
                    userId: currentUser.uid,
                    title: NEW_CHAT_TITLE, // Start with default title
                    createdAt: timestamp,
                    lastUpdated: timestamp
                });
                console.log("New chat document created:", newChatRef.id);
                // The chat list listener will detect the new chat and select it
                // switchChat(newChatRef.id); // Let the listener handle selection
            } catch (error) {
                console.error("Error creating new chat:", error);
                displayError("Failed to create the chat. Please try again.");
                setLoadingState(false);
            } finally {
                // Focus might be handled better after listener updates UI
                // if (!isTestMode && !isReviewMode) userInput.focus();
            }
        }

        function handleChatListClick(event) { /* ... (same as before - handles item click and delete button click) ... */
             const target = event.target;
             const deleteButton = target.closest('.delete-chat-button');
             if (deleteButton) {
                 event.stopPropagation(); // Prevent chat selection when deleting
                 const chatId = deleteButton.dataset.id;
                 const chatListItem = deleteButton.closest('.chat-list-item');
                 // Extract title carefully, removing the delete icon text
                 const chatTitle = chatListItem?.textContent?.replace(deleteButton.textContent, '').trim() || 'this chat';
                 if (chatId) {
                     console.log(`Delete button clicked for chat: ${chatId}, Title: "${chatTitle}"`);
                     confirmAndDeleteChat(chatId, chatTitle);
                 } else {
                     console.warn("Delete button clicked, but couldn't find chat ID.");
                 }
                 return; // Stop further processing
             }

             // Handle chat selection
             const item = target.closest('.chat-list-item');
             const clickedId = item?.dataset?.id;
             if (item && clickedId && clickedId !== activeChatId) {
                 console.log("Chat list item clicked, switching to:", clickedId);
                 switchChat(clickedId);
             } else if (item && clickedId && clickedId === activeChatId) {
                 console.log("Clicked already active chat, no switch needed:", clickedId);
             }
        }

        function confirmAndDeleteChat(chatId, chatTitle) { /* ... (same as before) ... */
            if (!currentUser || !chatId) return;
            // Use template literal for cleaner string formatting
            if (confirm(`Are you sure you want to permanently delete the chat "${chatTitle}" and all its messages? This cannot be undone.`)) {
                deleteChatFromFirestore(chatId);
            } else {
                console.log(`Deletion cancelled for chat: ${chatId}`);
            }
        }

        async function deleteChatFromFirestore(chatId) { /* ... (same as before - deletes chat doc and messages subcollection) ... */
            if (!currentUser || !chatId) {
                console.log("Delete chat aborted: Missing user or chatId.");
                return;
            }
            isDeletingChat = true; // Flag to prevent listener race conditions
            console.log(`[Delete Start] Deleting chat: ${chatId}. isDeletingChat = ${isDeletingChat}`);
            setLoadingState(true, "Deleting chat...");

            const chatDocRef = db.collection('chats').doc(chatId);
            const messagesRef = chatDocRef.collection('messages');

            try {
                // Delete all messages in the subcollection (using batch for efficiency)
                console.log(`[Delete Progress] Fetching messages for chat ${chatId}`);
                const messagesSnapshot = await messagesRef.get();
                if (!messagesSnapshot.empty) {
                    const batch = db.batch();
                    messagesSnapshot.docs.forEach(doc => {
                        batch.delete(doc.ref);
                    });
                    console.log(`[Delete Progress] Committing batch delete for ${messagesSnapshot.size} messages.`);
                    await batch.commit();
                    console.log(`[Delete Progress] Deleted ${messagesSnapshot.size} messages for chat ${chatId}`);
                } else {
                    console.log(`[Delete Progress] No messages found to delete for chat ${chatId}`);
                }

                // Delete the main chat document
                console.log(`[Delete Progress] Deleting chat document ${chatId}`);
                await chatDocRef.delete();
                console.log(`[Delete Success] Successfully deleted chat document: ${chatId}`);

                // If the deleted chat was the active one, reset the UI state
                if (activeChatId === chatId) {
                    console.log("[Delete Progress] Active chat was deleted. Resetting UI.");
                    activeChatId = null;
                    currentChatHistory = [];
                    if (activeChatListener) {
                        console.log("[Delete Progress] Detaching active chat listener.");
                        activeChatListener(); activeChatListener = null;
                    }
                    chatArea.innerHTML = ''; // Clear chat area
                    renderGreetingOrLoginPrompt(); // Show prompt/greeting
                    userInput.placeholder = "Select or create a chat";
                    sendButton.disabled = true; // Disable send
                    mcqModeCheckbox.disabled = true;
                } else {
                     console.log(`[Delete Progress] Deleted chat ${chatId} was not the active chat (${activeChatId}). UI state should update via listener.`);
                     // No immediate UI reset needed here, listener will refresh sidebar
                }

            } catch (error) {
                console.error(`[Delete Error] Error deleting chat ${chatId}:`, error);
                displayError(`Failed to delete the chat "${chatTitle || chatId}". Please try again.`);
                setLoadingState(false); // Ensure loading state is reset on error
            } finally {
                isDeletingChat = false; // Reset flag after operation completes
                console.log(`[Delete End] Finished delete attempt for chat ${chatId}. isDeletingChat = ${isDeletingChat}`);
                // Let the chatListListener handle the final sidebar update and potential selection of a new chat
                // No need to manually call setLoadingState(false) here if the listener handles it
            }
        }

        function switchChat(chatId) { /* ... (same as before) ... */
             if (!currentUser || !chatId || chatId === activeChatId) {
                 console.log("Switch chat condition not met or already active.");
                 return;
             }

             console.log("Switching to chat:", chatId);
             setLoadingState(true, "Loading chat...");
             activeChatId = chatId;

             highlightActiveChatInSidebar(); // Update sidebar highlight

             // Clear input and reset MCQ mode
             userInput.value = '';
             autoGrowTextarea();
             mcqModeCheckbox.checked = false;
             userInput.placeholder = "Loading messages..."; // Placeholder while loading

             // Load messages for the new chat (listener will handle UI updates)
             loadAndListenForActiveChat(chatId);

             // Focus might be better handled after messages load
             // if (!isTestMode && !isReviewMode) userInput.focus();
        }

        // --- Message Loading (Firestore) ---
        function loadAndListenForActiveChat(chatId) { /* ... (MODIFIED to restore correct placeholder) ... */
            if (!currentUser || !chatId) {
                console.log("Cannot load messages: Missing user or chatId.");
                chatArea.innerHTML = '';
                if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                renderGreetingOrLoginPrompt();
                setLoadingState(false);
                sendButton.disabled = true;
                mcqModeCheckbox.disabled = true;
                return;
            }

            // Detach previous listener if exists
            if (activeChatListener) { activeChatListener(); activeChatListener = null; }

            const messagesRef = db.collection('chats').doc(chatId)
                                  .collection('messages')
                                  .orderBy('timestamp', 'asc');

            chatArea.innerHTML = ''; // Clear area
            const loadingMsg = displayMessage("Loading chat history...", 'ai', ['thinking']);
            scrollToBottom(true);

            console.log(`Listening for messages in chat ${chatId}`);
            activeChatListener = messagesRef.onSnapshot(snapshot => {
                console.log(`Received messages snapshot for chat ${chatId}:`, snapshot.size, "messages");
                removeMessageElement(loadingMsg); // Remove "Loading..." message
                chatArea.innerHTML = ''; // Clear again before rendering new messages
                currentChatHistory = []; // Reset history array

                if (snapshot.empty && activeChatId === chatId) {
                    // Chat exists but has no messages
                    console.log("Chat is empty or newly created.");
                    const chatListItem = chatListContainer.querySelector(`.chat-list-item[data-id="${chatId}"]`);
                    const chatTitle = chatListItem?.textContent?.replace(DELETE_ICON, '').trim() || '';
                    // Display appropriate prompt based on title
                    if (chatTitle && chatTitle !== NEW_CHAT_TITLE) {
                         displayMessage("This chat is empty. Send a message to start!", 'ai');
                    } else {
                         renderGreetingOrLoginPrompt(); // Show generic greeting if it's untitled/new
                    }

                } else {
                    // Render messages
                    snapshot.forEach(doc => {
                        const msgData = doc.data();
                        // Ensure text exists, provide default if not
                        const text = typeof msgData.text === 'string' ? msgData.text : "";
                        const role = msgData.role === 'user' ? 'user' : 'model'; // 'model' for AI

                        // Add to local history cache (simple format for API context)
                         // --> Only add to history if it's not a special vocab response stored with image data
                         // We need to carefully manage history to avoid sending image data back
                         if (!msgData.isVocabResponse) {
                             currentChatHistory.push({
                                 role: role,
                                 parts: [{ text: text }]
                             });
                         } else {
                             // For vocab responses, perhaps add only the *textual part* to history?
                             // Or maybe skip adding AI vocab responses to history entirely to avoid complexity?
                             // Let's skip adding AI vocab responses to history for now.
                             if (role === 'user') {
                                 currentChatHistory.push({
                                     role: role,
                                     parts: [{ text: text }]
                                 });
                             }
                         }

                        // Display the message, passing full data for potential MCQ/Vocab button rendering
                        displayMessage(text, role, [], null, msgData);
                    });
                }
                scrollToBottom(true); // Scroll after rendering
                setLoadingState(false); // Turn off loading indicator

                // Enable input/send now that chat is loaded
                sendButton.disabled = !API_KEY; // Enable if API key exists
                mcqModeCheckbox.disabled = !API_KEY;
                // Restore correct placeholder
                userInput.placeholder = "Enter prompt (e.g., 'synonym for quick', 'idiom break a leg')";
                if (!isTestMode && !isReviewMode) userInput.focus(); // Focus input


            }, error => {
                console.error(`Error listening for messages in chat ${chatId}:`, error);
                displayError("Could not load messages for this chat. Please check your connection.");
                removeMessageElement(loadingMsg);
                chatArea.innerHTML = ''; // Clear area on error
                currentChatHistory = []; // Reset history
                setLoadingState(false); // Turn off loading
                sendButton.disabled = true; // Disable send on error
                mcqModeCheckbox.disabled = true;
                userInput.placeholder = "Error loading chat";
            });
        }

        // --- Message Sending (Gemini API & Firestore Save) ---
        // --- UPDATED handleSendMessage function ---
        async function handleSendMessage() {
            const userMessageText = userInput.value.trim();

            if (!API_KEY) { displayError("Gemini API Key not set. Reload to enter. / Gemini API Key அமைக்கப்படவில்லை. உள்ளிட மீண்டும் ஏற்றவும்."); return; }
            if (!currentUser) { displayError("Please log in first. / முதலில் உள்நுழையவும்."); return; }
            if (!activeChatId) { displayError("Please select or create a chat first. / முதலில் ஒரு உரையாடலைத் தேர்ந்தெடுக்கவும் அல்லது உருவாக்கவும்."); return; }
            if (!userMessageText || sendButton.disabled) return; // Don't send empty or while disabled

            const isMCQRequest = mcqModeCheckbox.checked;
            // --- Vocab Keyword Detection ---
            const lowerCaseMessage = userMessageText.toLowerCase();
            const isVocabRequest = !isMCQRequest && VOCAB_KEYWORDS.some(keyword => lowerCaseMessage.includes(keyword));
            // --- End Vocab Detection ---

            setLoadingState(true, "Sending..."); // Disable inputs, show thinking

            // Clear input immediately
            userInput.value = '';
            autoGrowTextarea();
            if (isMCQRequest) mcqModeCheckbox.checked = false; // Uncheck MCQ box

            const timestamp = firebase.firestore.FieldValue.serverTimestamp();
            const messagesColRef = db.collection('chats').doc(activeChatId).collection('messages');
            const chatDocRef = db.collection('chats').doc(activeChatId);

            let isFirstUserMessageInNewChat = false;
            let potentialTestTitle = null; // For auto-generated test title

            // Prepare user message data for Firestore
            const userMsgData = {
                role: "user",
                text: userMessageText,
                timestamp: timestamp
            };

            // Save user message immediately (always done)
            try {
                // Check if it's the first message in an untitled chat to trigger title generation
                const chatSnap = await chatDocRef.get();
                if (chatSnap.exists && chatSnap.data().title === NEW_CHAT_TITLE) {
                    const messagesSnap = await messagesColRef.limit(1).get();
                    if (messagesSnap.empty) {
                        isFirstUserMessageInNewChat = true;
                    }
                }

                // Save user message
                const userMsgRef = await messagesColRef.add(userMsgData); // Get ref for potential history update later
                // Update chat's lastUpdated timestamp
                await chatDocRef.update({ lastUpdated: timestamp });
                console.log("User message saved to Firestore.");

                // If first message, generate and update chat title
                if (isFirstUserMessageInNewChat) {
                    console.log("First user message detected, attempting to generate chat title.");
                    const generatedTitle = generateChatTitle(userMessageText);
                    if (generatedTitle && generatedTitle !== NEW_CHAT_TITLE) {
                        await updateActiveChatTitle(generatedTitle);
                        console.log("Chat title updated automatically:", generatedTitle);
                    } else {
                        console.log("Generated chat title was empty or same as default, not updating.");
                    }
                }
                // Add user message to local history cache IMMEDIATELY after saving
                 currentChatHistory.push({ role: "user", parts: [{ text: userMessageText }] });

            } catch(error) {
                console.error("Error saving user message or updating title:", error);
                displayError("Failed to send message. Please check connection and try again.");
                setLoadingState(false);
                return; // Stop processing if user message save failed
            }

            // Display "Thinking..." message (will be removed later)
            const thinking = displayMessage("Thinking...", 'ai', ['thinking']);
            scrollToBottom(); // Scroll to show thinking message

            // Prepare history for API call (use the up-to-date local cache)
            const requestHistory = [ ...currentChatHistory ]; // Use the cache

            // Modify prompt and prepare API history copy based on request type
            let promptForAPI = userMessageText;
            let modelToUse = TEXT_MODEL_NAME; // Default model
            let apiBody = { // Default body structure
                 contents: requestHistory,
                 safetySettings: [ // Standard safety settings
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                 ]
            };

            if (isVocabRequest) {
                console.log("Vocab mode detected.");
                modelToUse = VOCAB_MODEL_NAME; // Use the specific model

                // *** Vocab Prompt ***
                // Ask for text AND image data
                // NOTE: Requesting direct image generation might fail or require different structure/endpoint
                 promptForAPI = `For the request "${userMessageText}", provide the following information for each relevant word/idiom found (limit to a maximum of 3 entries if multiple words are requested):
1.  Word/Idiom: The English word or idiom.
2.  Tamil Meaning: Accurate Tamil translation.
3.  English Example: A clear sentence using the word/idiom in English.
4.  Tamil Example: An accurate Tamil translation of the English example sentence.
5.  Image Prompt: Generate a short, descriptive text prompt suitable for an AI image generator, related to the word/idiom.
6.  Image: Generate one image based on the Image Prompt (if possible within this model's capability).

Format the text response clearly, perhaps using Markdown or numbered lists. If you generate an image, include its data. If image generation fails or isn't supported, just provide the text parts including the Image Prompt.`;

                // Modify the *last* user message in the history *copy* for the API call
                let vocabHistoryForCall = [...requestHistory];
                if (vocabHistoryForCall.length > 0 && vocabHistoryForCall[vocabHistoryForCall.length - 1].role === 'user') {
                    vocabHistoryForCall[vocabHistoryForCall.length - 1] = { role: "user", parts: [{ text: promptForAPI }] };
                } else {
                    vocabHistoryForCall.push({ role: "user", parts: [{ text: promptForAPI }] });
                }

                // Update the API body for the vocab model call
                apiBody = {
                     contents: vocabHistoryForCall,
                     // generationConfig might be needed for image models
                     generationConfig: {
                       responseMimeType: "multipart/mixed", // Try requesting mixed content
                     },
                     safetySettings: [ // Standard safety settings
                         { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                         { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                         { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                         { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                     ]
                };
                console.log("Using Vocab Model:", modelToUse);

            } else if (isMCQRequest) {
                // --- MCQ Request Logic (mostly same as before) ---
                modelToUse = TEXT_MODEL_NAME; // Ensure text model for MCQs
                potentialTestTitle = generateChatTitle(userMessageText);
                if (potentialTestTitle === NEW_CHAT_TITLE || !potentialTestTitle) {
                    potentialTestTitle = "Generated Test"; // Fallback title
                }
                potentialTestTitle += ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`;

                promptForAPI = `${userMessageText}\n\nPlease generate multiple choice questions... [rest of MCQ prompt remains same] ...Do not include any text outside the JSON structure.`;

                let mcqHistoryForCall = [...requestHistory];
                if (mcqHistoryForCall.length > 0 && mcqHistoryForCall[mcqHistoryForCall.length - 1].role === 'user') {
                    mcqHistoryForCall[mcqHistoryForCall.length - 1] = { role: "user", parts: [{ text: promptForAPI }] };
                } else {
                    mcqHistoryForCall.push({ role: "user", parts: [{ text: promptForAPI }] });
                }
                 apiBody.contents = mcqHistoryForCall; // Update contents for MCQ
                console.log("MCQ mode: Modified prompt for BILINGUAL API, potential title:", potentialTestTitle);
            } else {
                 // Standard text request, use default model and history
                 modelToUse = TEXT_MODEL_NAME;
                 apiBody.contents = requestHistory; // Already set by default
                 console.log("Standard text request.");
            }

            // Construct the final API URL
            const finalApiUrl = API_URL_BASE + modelToUse + ':generateContent?key=' + API_KEY;

            console.warn(`Calling Gemini API (${modelToUse}) using client-side key. Replace with a secure Cloud Function.`);
            try {
                const response = await fetch(finalApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(apiBody), // Use the constructed body
                });

                removeMessageElement(thinking); // Remove "Thinking..."

                // Prepare default AI response structure for Firestore
                let aiMsgData = {
                    role: "model",
                    text: "Error: No valid response received from API.",
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    mcqData: null,
                    mcqTitle: null,
                    isVocabResponse: false, // New flag
                    vocabDetails: null, // To store parsed vocab text
                    imageData: null, // To store base64 image data
                    imageMimeType: null // To store image mime type
                };
                let displayAsError = true;

                if (!response.ok) {
                    // Handle API errors (like 4xx, 5xx) - same as before
                    let errorDetails = `API error (${response.status})`;
                     try {
                         const errorText = await response.text(); // Get raw error text
                         console.error("Raw API Error Response:", errorText);
                         try {
                              const errorJson = JSON.parse(errorText);
                              errorDetails = errorJson.error?.message || errorDetails;
                         } catch {
                              errorDetails = errorText || errorDetails; // Use raw text if JSON parse fails
                         }
                     } catch {}
                     console.error("API Error:", response.status, errorDetails);
                     aiMsgData.text = `Error: ${errorDetails} (Model: ${modelToUse})`; // Include model name in error
                     // Specific check for invalid API key
                     if (response.status === 400 && errorDetails.toLowerCase().includes('api key not valid')) {
                          localStorage.removeItem(STORAGE_KEY_API_KEY); API_KEY=''; // Clear invalid key
                          aiMsgData.text += " Your API Key seems invalid and has been cleared. Reload the page to enter a new key. / உங்கள் API விசை தவறானது போல் தெரிகிறது மற்றும் அழிக்கப்பட்டுள்ளது. புதிய விசையை உள்ளிட பக்கத்தை மீண்டும் ஏற்றவும்.";
                     } else if (response.status === 404) {
                          aiMsgData.text += ` Model '${modelToUse}' might not be found or accessible via this API endpoint.`;
                     }

                } else {
                    // Handle successful API response (200 OK)
                    const data = await response.json();
                    console.log("API Response Data:", data); // Log the full response

                    let rawAiText = "";
                    let imageDataPart = null;
                    let blocked = false;
                    displayAsError = false;

                    // Check for safety blocks (prompt or response) - same as before
                     if (data.promptFeedback?.blockReason) {
                         aiMsgData.text = `Blocked: Your prompt was blocked (${data.promptFeedback.blockReason}).`;
                         blocked = true; displayAsError = true; console.warn("Prompt blocked:", data.promptFeedback.blockReason);
                     } else if (data.candidates?.[0]?.finishReason === 'SAFETY') {
                          aiMsgData.text = `Blocked: The response was blocked due to safety concerns.`;
                          blocked = true; displayAsError = true; console.warn("Response blocked due to safety.");
                     }
                     // Check if candidates exist and have content
                     else if (data.candidates?.[0]?.content?.parts && data.candidates[0].content.parts.length > 0) {
                        // Process potentially multiple parts (text, image)
                        data.candidates[0].content.parts.forEach(part => {
                            if (part.text) {
                                rawAiText += part.text + "\n"; // Concatenate text parts
                            }
                            // --- Image Data Handling ---
                            if (part.inlineData && part.inlineData.data && part.inlineData.mimeType) {
                                console.log("Image data found in response:", part.inlineData.mimeType);
                                imageDataPart = part.inlineData;
                            }
                            // --- End Image Handling ---
                        });
                        rawAiText = rawAiText.trim(); // Trim concatenated text

                        if (!rawAiText && !imageDataPart) {
                             // Neither text nor image found, treat as error
                             aiMsgData.text = "Sorry, I received an empty response.";
                             displayAsError = true;
                             console.warn("Empty content in response parts.");
                         } else {
                             aiMsgData.text = rawAiText || "(No text content received)"; // Default text if only image exists

                             // --- Process based on request type ---
                             if (isVocabRequest) {
                                 aiMsgData.isVocabResponse = true;
                                 aiMsgData.vocabDetails = rawAiText; // Store the formatted text
                                 if (imageDataPart) {
                                     aiMsgData.imageData = imageDataPart.data; // Base64 data
                                     aiMsgData.imageMimeType = imageDataPart.mimeType;
                                     // Update main text to indicate image presence
                                     if (!rawAiText) aiMsgData.text = "(Image received, no text description)";
                                     console.log("Storing vocab text and image data.");
                                 } else {
                                      console.log("Storing vocab text, no image data received or processed.");
                                      // Add a note if image was expected but not received
                                      if (!aiMsgData.text.includes("Image generation failed") && modelToUse === VOCAB_MODEL_NAME) {
                                           aiMsgData.text += "\n\n*(Image generation might not be supported by this model/endpoint or failed).*";
                                      }
                                 }
                                 // Don't add AI vocab response to chat history (already decided)

                             } else if (isMCQRequest) {
                                 // --- MCQ Parsing (same as before) ---
                                 console.log("Attempting to parse BILINGUAL MCQ JSON from response...");
                                  try {
                                      const jsonMatch = rawAiText.match(/```json\s*([\s\S]*?)\s*```/);
                                      const jsonString = jsonMatch ? jsonMatch[1].trim() : rawAiText.trim();
                                      if (jsonString.startsWith('[') && jsonString.endsWith(']')) {
                                          const mcqs = JSON.parse(jsonString);
                                          const isValidMCQArray = Array.isArray(mcqs) && mcqs.length > 0 &&
                                              mcqs.every(q => q && q.question?.en && q.question?.ta && Array.isArray(q.options) && q.options.length === 4 && q.options.every(opt => opt?.en && opt?.ta) && q.answer && q.explanation?.en && q.explanation?.ta);

                                          if (isValidMCQArray) {
                                              const summaryText = `Successfully generated ${mcqs.length} MCQs. Click below to start. / ${mcqs.length} MCQகள் வெற்றிகரமாக உருவாக்கப்பட்டுள்ளன. தொடங்க கீழே கிளிக் செய்யவும்.`;
                                              aiMsgData.text = summaryText;
                                              aiMsgData.mcqData = mcqs;
                                              aiMsgData.mcqTitle = potentialTestTitle;
                                              displayAsError = false;
                                              // Add AI's MCQ summary text to history
                                              currentChatHistory.push({ role: "model", parts: [{ text: summaryText }] });
                                          } else { /* ... handle invalid MCQ JSON ... */
                                               console.warn("MCQ JSON validation failed."); aiMsgData.text = "Received MCQ data, but format is incorrect.\n\n" + rawAiText; displayAsError = true;
                                               // Add raw incorrect response to history
                                                currentChatHistory.push({ role: "model", parts: [{ text: aiMsgData.text }] });
                                           }
                                      } else { /* ... handle non-JSON array ... */
                                           console.warn("MCQ response not JSON array."); aiMsgData.text = "Expected MCQs in JSON, received different format.\n\n" + rawAiText; displayAsError = true;
                                            // Add raw incorrect response to history
                                            currentChatHistory.push({ role: "model", parts: [{ text: aiMsgData.text }] });
                                       }
                                  } catch (parseError) { /* ... handle JSON parse error ... */
                                       console.error("MCQ JSON parse error:", parseError); aiMsgData.text = "Error parsing MCQ JSON.\n\n" + rawAiText; displayAsError = true;
                                       // Add raw incorrect response to history
                                        currentChatHistory.push({ role: "model", parts: [{ text: aiMsgData.text }] });
                                   }
                             } else {
                                 // Standard text response
                                 displayAsError = false;
                                  // Add standard AI text response to history
                                 currentChatHistory.push({ role: "model", parts: [{ text: rawAiText }] });
                             }
                         } // End of valid content processing
                     } else {
                         // No valid candidates or content parts found
                         console.warn("Unexpected API response format or empty content:", data);
                         aiMsgData.text = "Sorry, I received an unexpected response format. / மன்னிக்கவும், எதிர்பாராத பதில் வடிவத்தைப் பெற்றேன்.";
                         displayAsError = true;
                         // Add this error to history
                         currentChatHistory.push({ role: "model", parts: [{ text: aiMsgData.text }] });
                     }
                } // End of successful response handling

                // --- Save AI response (or error) to Firestore ---
                try {
                    // IMPORTANT: Ensure imageData and vocabDetails are saved if they exist
                    const dataToSave = { ...aiMsgData };
                    // Avoid saving large image data if not needed in Firestore long-term?
                    // For now, let's save everything.
                     await messagesColRef.add(dataToSave);
                     await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() });
                     console.log("AI response/error saved to Firestore.", dataToSave);
                     // Listener will display the message. If it was an error, it will show error styling.

                } catch (saveError) {
                     console.error("Error saving AI response to Firestore:", saveError);
                     // Display error in UI if saving failed
                     displayError(`Received response, but failed to save it: ${aiMsgData.text}`);
                     // Manually add error message to history if save failed
                     currentChatHistory.push({ role: "model", parts: [{ text: `(Save Error) ${aiMsgData.text}` }] });
                }

            } catch (fetchError) {
                // Handle errors during the fetch call itself (network issues, etc.)
                console.error("Fetch/Processing Error:", fetchError);
                removeMessageElement(thinking); // Ensure thinking message is removed
                const errorText = `Error communicating with the API: ${fetchError.message || "Check network connection."} / API உடன் தொடர்புகொள்வதில் பிழை: ${fetchError.message || "நெட்வொர்க் இணைப்பைச் சரிபார்க்கவும்."}`;
                displayError(errorText); // Show error in chat

                // Attempt to save the fetch error to history for context
                try {
                    const errorMsgData = { role: "model", text: errorText, timestamp: firebase.firestore.FieldValue.serverTimestamp() };
                    await messagesColRef.add(errorMsgData);
                    await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() });
                     // Add fetch error to local history
                     currentChatHistory.push({ role: "model", parts: [{ text: errorText }] });
                } catch (saveError) {
                     console.error("Failed to save fetch/processing error to history:", saveError);
                }
            } finally {
                setLoadingState(false); // Re-enable inputs
                if (!isTestMode && !isReviewMode && activeChatId) {
                     userInput.focus();
                }
            }
        } // End of handleSendMessage


        // --- Chat Title Generation/Update ---
        function generateChatTitle(firstUserMessageText) { /* ... (same as before) ... */
             if (!firstUserMessageText || typeof firstUserMessageText !== 'string') return NEW_CHAT_TITLE;
             const text = firstUserMessageText.trim();
             if (!text) return NEW_CHAT_TITLE;
             // Take first 5 words, remove trailing punctuation
             const title = text.split(/\s+/).slice(0, 5).join(' ').replace(/[.,!?;:]+$/, '');
             // Limit length
             return title.length > 35 ? title.substring(0, 32) + '...' : title;
        }
        async function updateActiveChatTitle(newTitle) { /* ... (same as before) ... */
              if (!currentUser || !activeChatId || !newTitle || typeof newTitle !== 'string' || !newTitle.trim() || newTitle.trim() === NEW_CHAT_TITLE) {
                  console.log("Skipping chat title update (invalid conditions).");
                  return;
              }
              const finalTitle = newTitle.trim();
              const chatDocRef = db.collection('chats').doc(activeChatId);
              try {
                  await chatDocRef.update({ title: finalTitle });
                  console.log(`Chat ${activeChatId} title updated to: "${finalTitle}"`);
                  // Listener will update the sidebar UI
              } catch (error) {
                  console.error("Error updating chat title in Firestore:", error);
              }
         }

        // --- UI & Message Display Helpers ---
        function autoGrowTextarea() { /* ... (same as before) ... */ userInput.style.height='auto'; userInput.style.height=(userInput.scrollHeight)+'px'; }
        function handleInputKeydown(event) { /* ... (same as before) ... */ if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();handleSendMessage();} }
        function handleSuggestionClick(event) { /* ... (same as before) ... */ if(event.target.classList.contains('suggestion-chip')){userInput.value=event.target.dataset.prompt||'';autoGrowTextarea();userInput.focus();} }

        function displayError(text) { /* ... (same as before) ... */
            console.error("Displaying Error:", text);
            displayMessage(`Error: ${text}`, 'ai', ['error-message']);
            scrollToBottom();
        }
        function scrollToBottom(immediate = false) { /* ... (same as before) ... */ chatArea.scrollTo({top:chatArea.scrollHeight,behavior:immediate?'auto':'smooth'}); }
        function removeMessageElement(element) { /* ... (same as before) ... */ if(element && element.parentNode === chatArea) { chatArea.removeChild(element); } }

        function setLoadingState(isLoading, message = "Generating...") { /* ... (updated logic) ... */
             // Determine disabled state based on loading OR auth/chat state
             const isDisabledOverall = isLoading || !currentUser || !API_KEY; // General disable condition
             const isSendDisabled = isDisabledOverall || !activeChatId; // Send requires an active chat

             userInput.disabled = isDisabledOverall;
             sendButton.disabled = isSendDisabled;
             mcqModeCheckbox.disabled = isSendDisabled; // MCQ tied to send button

             // Sidebar controls depend on user login, not active chat
             const isControlDisabled = isLoading || !currentUser;
             startChatButton.disabled = isControlDisabled;
             testSearchInput.disabled = isControlDisabled;
             decreaseTextBtn.disabled = isControlDisabled || (currentUser && currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER);
             increaseTextBtn.disabled = isControlDisabled || (currentUser && currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER);
             themeToggleButton.disabled = isControlDisabled;

             // Update placeholder based on state
             if (isLoading) {
                 userInput.placeholder = message;
             } else if (!currentUser) {
                 userInput.placeholder = "Please log in";
             } else if (!activeChatId) {
                 userInput.placeholder = "Select or create a chat";
             } else if (!API_KEY) {
                 userInput.placeholder = "API Key missing. Reload page.";
             } else {
                 userInput.placeholder = "Enter prompt (e.g., 'synonym for quick', 'idiom break a leg')"; // Updated placeholder
             }
         }

        function switchView(viewName, cameFromTests = false) { /* ... (same as before) ... */
            console.log("Switching view to:", viewName, "Came from tests:", cameFromTests);
            chatView.classList.remove('active');
            reviewView.classList.remove('active');
            testView.classList.remove('active');
            appContainer.classList.remove('hidden'); // Ensure main app is visible unless test view

            isTestMode = false;
            isReviewMode = false;
            cameFromAllTestsList = cameFromTests;

            // Hide footer buttons initially
            saveReviewBtn.style.display = 'none';
            exitReviewBtn.style.display = 'none';

            if(viewName==='test'){
                appContainer.classList.add('hidden'); // Hide main app container for focused test view
                testView.classList.add('active');
                isTestMode=true;
            } else if(viewName==='review'){
                reviewView.classList.add('active');
                isReviewMode=true;
                // Show exit button in review view
                exitReviewBtn.style.display = 'inline-block';
                exitReviewBtn.textContent = cameFromAllTestsList ? "Back to All Tests" : "Back to Chat";
                // Save button visibility handled by displayReview
            } else { // Default to chat view
                chatView.classList.add('active');
                // Focus input only if logged in, chat active, and API key present
                if (currentUser && activeChatId && API_KEY) {
                    userInput.focus();
                }
            }

            // Clear test timer if switching away from test view
            if (viewName !== 'test' && testTimerInterval) {
                clearInterval(testTimerInterval);
                testTimerInterval = null;
                console.log("Test timer cleared.");
            }
        }

        // --- UPDATED displayMessage function ---
        function displayMessage(text, sender, cssClasses = [], appendHtml = null, messageData = null) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', `${sender}-message`);
            if (cssClasses && cssClasses.length > 0) {
                messageElement.classList.add(...cssClasses);
            }

            // Check if this is a special vocab response from Firestore
            const isVocab = messageData?.isVocabResponse === true;
            let formattedText = "";

            if (isVocab && messageData.vocabDetails) {
                 // Handle Vocab Formatting - Assume vocabDetails contains markdown-like text from API
                 console.log("Displaying Vocab Response");
                 const vocabDiv = document.createElement('div');
                 vocabDiv.classList.add('vocab-entry'); // Add specific class for styling

                 // Use basic markdown-like parsing for the structure requested in the prompt
                 // This is a simplified parser, might need refinement based on actual API output
                 let currentEntryHtml = "";
                 let entryCounter = 0;
                 const lines = messageData.vocabDetails.split('\n');
                 let listStarted = false;

                 lines.forEach(line => {
                     line = line.trim();
                     if (!line) return;

                     if (line.match(/^\d+\.\s*Word\/Idiom:/i)) { // Start of a new entry
                         if (currentEntryHtml) { // Append previous entry if exists
                             if (!listStarted) { vocabDiv.innerHTML += "<ol>"; listStarted = true; }
                             vocabDiv.querySelector('ol').innerHTML += `<li>${currentEntryHtml}</li>`;
                         }
                         entryCounter++;
                         currentEntryHtml = `<span class="vocab-word">${line.substring(line.indexOf(':') + 1).trim()}</span>`;
                     } else if (line.match(/^Tamil Meaning:/i)) {
                         currentEntryHtml += `<span class="vocab-meaning">${line.substring(line.indexOf(':') + 1).trim()}</span>`;
                     } else if (line.match(/^English Example:/i)) {
                          currentEntryHtml += `<span class="vocab-example"><span class="vocab-example-label">EN:</span> ${line.substring(line.indexOf(':') + 1).trim()}</span>`;
                     } else if (line.match(/^Tamil Example:/i)) {
                          currentEntryHtml += `<span class="vocab-example"><span class="vocab-example-label">TA:</span> ${line.substring(line.indexOf(':') + 1).trim()}</span>`;
                     } else if (line.match(/^Image Prompt:/i)) {
                          // Display the image prompt (actual image handled later)
                          currentEntryHtml += `<span class="vocab-example"><span class="vocab-example-label">IMG Prompt:</span> <i>${line.substring(line.indexOf(':') + 1).trim()}</i></span>`;
                     } else if (currentEntryHtml) {
                         // Append continuation lines to the last relevant part (e.g., explanation)
                         // This part is tricky without a fixed API structure. Let's append as plain text for now.
                          // currentEntryHtml += `<br>${line}`; // Maybe append as part of previous span? Needs better structure.
                     }
                 });

                 // Append the last entry
                 if (currentEntryHtml) {
                     if (!listStarted) { vocabDiv.innerHTML += "<ol>"; listStarted = true; }
                     vocabDiv.querySelector('ol').innerHTML += `<li>${currentEntryHtml}</li>`;
                 }
                 if (listStarted) vocabDiv.innerHTML += "</ol>";

                 // Append any remaining text that wasn't part of the structured list
                 if (!listStarted && messageData.vocabDetails) {
                     vocabDiv.innerHTML = messageData.vocabDetails.replace(/\n/g, '<br>'); // Fallback display
                 }

                 messageElement.appendChild(vocabDiv);

                 // --- Handle Image Display ---
                 if (messageData.imageData && messageData.imageMimeType) {
                     console.log("Displaying Vocab Image");
                     const imgContainer = document.createElement('div');
                     imgContainer.classList.add('vocab-image-container');
                     const img = document.createElement('img');
                     img.src = `data:${messageData.imageMimeType};base64,${messageData.imageData}`;
                     img.alt = "Vocabulary Image"; // Add alt text
                     imgContainer.appendChild(img);
                     // Optional: Add info about the image if needed
                     // const imgInfo = document.createElement('div');
                     // imgInfo.classList.add('image-info');
                     // imgInfo.textContent = `(${messageData.imageMimeType})`;
                     // imgContainer.appendChild(imgInfo);
                     messageElement.appendChild(imgContainer);
                 } else if (messageData.vocabDetails && messageData.vocabDetails.includes("Image generation failed")) {
                     // Optionally display a placeholder or message if image generation specifically failed
                     console.log("Image generation failed or not supported message detected.");
                 }

                 formattedText = ""; // We've manually built the content

            } else {
                 // --- Standard Text / MCQ Offer / Error Formatting (mostly same as before) ---
                 const tempDiv = document.createElement('div');
                 tempDiv.innerText = text || ""; // Use innerText to prevent script injection
                 formattedText = tempDiv.innerHTML; // Get HTML-escaped text

                 // Apply formatting (Bold, Italic, Code Blocks, Inline Code)
                 formattedText = formattedText
                    .replace(/```([\s\S]*?)```/g, (match, code) => {
                        const escapedCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        return `<pre><code>${escapedCode}</code></pre>`;
                    })
                    .replace(/`([^`]+)`/g, (match, code) => {
                        const escapedCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        return `<code>${escapedCode}</code>`;
                    })
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                    .replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)/g, '<em>$1</em>') // Italic
                    .replace(/\n/g, '<br>'); // Newlines

                 messageElement.innerHTML = formattedText; // Set formatted standard text

                 // Handle MCQ Offer (Uses mcqData and mcqTitle from Firestore document)
                 if (messageData && messageData.role === 'model' && messageData.mcqData && Array.isArray(messageData.mcqData) && messageData.mcqData.length > 0) {
                     console.log("Rendering message with MCQ offer:", messageData.mcqData.length, "questions. Title:", messageData.mcqTitle);
                     displayMCQOffer(messageData.mcqData, messageData.mcqTitle, messageElement);
                 }
                 else if (appendHtml) { // Append extra HTML if provided
                     const appendDiv = document.createElement('div');
                     appendDiv.innerHTML = appendHtml;
                     while (appendDiv.firstChild) {
                         messageElement.appendChild(appendDiv.firstChild);
                     }
                 }
                 // --- End Standard Formatting ---
            }


            chatArea.appendChild(messageElement);

             // Try to render MathJax if available (applies to all messages)
             try {
                 if (typeof MathJax !== "undefined" && MathJax.typesetPromise) {
                     MathJax.typesetPromise([messageElement]).catch(err => console.error('MathJax typeset error on message:', err));
                 }
             } catch (e) { console.error("MathJax call failed:", e); }

            return messageElement; // Return the created element
        } // End of displayMessage


        // --- MCQ/Test Specific Functions ---

        // Handles clicks on the "Start Mock Test" button within a chat message
        function handleChatAreaClick(event) { /* ... (updated for mcqTitle) ... */
            const startButton = event.target.closest('.start-test-button');
            if (startButton) {
                 // Get data and title directly from the button's attributes
                 const mcqDataString = startButton.dataset.mcq;
                 const titleFromButton = startButton.dataset.mcqTitle; // Get the stored title
                 let mcqs = null;

                 if (mcqDataString) {
                    try {
                        mcqs = JSON.parse(mcqDataString); // Parse the MCQ data
                    } catch (e) {
                        console.error("Failed to parse MCQ data from button attribute:", e);
                        displayError("Could not start the test. Failed to read question data.");
                        return;
                    }
                 }

                 if (mcqs && Array.isArray(mcqs) && mcqs.length > 0) {
                     console.log("Start Test button clicked, initiating test with data and title from button...");
                     // Pass the parsed MCQs AND the title to startMockTest
                     startMockTest(mcqs, titleFromButton || null); // Use title or null if absent
                 } else {
                     console.error("MCQ data not found or invalid in button attribute when 'Start Test' button clicked.");
                     displayError("Could not start the test. MCQ data seems missing or invalid.");
                 }
            }
        }

        // Appends the "Start Mock Test" button to an AI message element
        function displayMCQOffer(mcqData, mcqTitle, aiMessageElement) { /* ... (updated for mcqTitle) ... */
             if (aiMessageElement.querySelector('.start-test-button')) return; // Don't add if already exists

             const questionCount = mcqData.length;
             const button = document.createElement('button');
             button.classList.add('start-test-button');
             button.textContent = `Start Mock Test (${questionCount} Questions)`;
             button.title = mcqTitle || `Start a test with ${questionCount} questions`; // Tooltip

             // Store the data AND title ON the button
             try {
                button.dataset.mcq = JSON.stringify(mcqData); // Store MCQs as JSON string
                // Store the title directly as another data attribute if it exists
                if (mcqTitle) {
                    button.dataset.mcqTitle = mcqTitle;
                }
             } catch (e) {
                 console.error("Failed to stringify MCQ data or set title for button attribute:", e);
                 return; // Don't add button if data can't be stored
             }

             const buttonContainer = document.createElement('div');
             buttonContainer.style.marginTop = '10px'; // Space above button
             buttonContainer.appendChild(button);
             aiMessageElement.appendChild(buttonContainer); // Add to the AI message bubble
        }

        // --- NEW Function: Toggle Test Language ---
        function toggleTestLanguage() {
            currentTestLanguage = (currentTestLanguage === 'en') ? 'ta' : 'en'; // Switch language state
            testLanguageToggle.textContent = (currentTestLanguage === 'en') ? 'தமிழ்' : 'English'; // Update button text
            // Re-display the current question in the new language
            displayTestQuestion(currentQuestionIndex);
            console.log("Switched test language to:", currentTestLanguage);
        }

        // --- MODIFIED startMockTest function ---
        function startMockTest(mcqs, title = null) {
            if (!currentUser) { displayError("Please log in to start a test. / சோதனையைத் தொடங்க உள்நுழையவும்."); return; }
            if (!mcqs || mcqs.length === 0) {
                 displayError("No questions available for this test. / இந்த சோதனைக்கு கேள்விகள் இல்லை.");
                 if (cameFromAllTestsList) { switchView('chat'); } // Go back if came from list and no questions
                 return;
            }
            console.log("Starting mock test with", mcqs.length, "questions. Provided Title:", title);

            currentTestMCQs = mcqs; // Store the questions for this test session
            currentQuestionIndex = 0;
            userAnswers = new Array(mcqs.length).fill(null); // Reset user answers
            reviewResultsCache = null; // Clear any previous review cache

            // Reset language to English when starting a new test
            currentTestLanguage = 'en';
            testLanguageToggle.textContent = 'தமிழ்'; // Reset button text

            switchView('test'); // Switch to the test view interface

            displayTestQuestion(0); // Display the first question
            startTestTimer(); // Start the timer

            // Use the passed title, provide a default if null/empty
            const finalTitle = (title && title.trim()) ? title.trim() : `Mock Test (${mcqs.length} Questions)`;
            testTitle.textContent = finalTitle;
        }

        // --- MODIFIED displayTestQuestion function (Bilingual) ---
        function displayTestQuestion(index) {
            if (index < 0 || index >= currentTestMCQs.length) return;

            currentQuestionIndex = index;
            const questionData = currentTestMCQs[index];

            // *** Get text based on currentTestLanguage ***
            const lang = currentTestLanguage; // 'en' or 'ta'

            // Get question text, fallback to English if Tamil is missing or object structure is wrong
            const questionText = questionData.question?.[lang] || questionData.question?.en || "(Question text missing)";
            testQuestionNumber.textContent = `Question ${index + 1}`; // Keep number in English
            testQuestion.innerHTML = questionText; // Use innerHTML for potential formatting

            testOptionsContainer.innerHTML = ''; // Clear previous options

            const options = Array.isArray(questionData.options) ? questionData.options : [];
            const optionLetters = ['A', 'B', 'C', 'D']; // Standard option letters

            options.forEach((optionObj, optionIndex) => {
                 if (optionIndex >= optionLetters.length) return; // Only handle A, B, C, D

                 // *** Get option text based on currentTestLanguage, fallback to English ***
                 const optionText = optionObj?.[lang] || optionObj?.en || '(Empty Option)';

                 const label = document.createElement('label');
                 const input = document.createElement('input');
                 input.type = 'radio';
                 input.name = `q_${index}`; // Group radio buttons for the same question
                 input.value = optionIndex; // Store the index (0-3) as the value
                 input.checked = (userAnswers[index] === optionIndex); // Check if this was the user's previous answer
                 input.onchange = () => handleOptionSelect(optionIndex); // Update answer on change

                 label.appendChild(input);
                 label.appendChild(document.createTextNode(` ${optionLetters[optionIndex]}. ${optionText}`)); // Display letter and text
                 testOptionsContainer.appendChild(label);
            });

            // Re-render MathJax for the new question/options
             try {
                 if (typeof MathJax !== "undefined" && MathJax.typesetPromise) {
                     MathJax.typesetPromise([testQuestion, testOptionsContainer]).catch(err => console.error('MathJax typeset error on test question:', err));
                 }
             } catch(e){ console.error("MathJax call failed:", e); }

            // Update navigation button states
            prevQuestionBtn.disabled = (index === 0);
            nextQuestionBtn.disabled = (index === currentTestMCQs.length - 1);
            // Update question counter display
            questionCounter.textContent = `Q: ${index + 1} / ${currentTestMCQs.length}`;
        }

        function handleOptionSelect(optionIndex) { /* ... (same as before) ... */
            if (currentQuestionIndex >= 0 && currentQuestionIndex < userAnswers.length) {
                userAnswers[currentQuestionIndex] = optionIndex; // Store the selected option index (0-3)
                console.log(`Answered Q${currentQuestionIndex + 1}: Option index ${optionIndex}`);
            }
        }
        function handleTestNavigation(direction) { /* ... (same as before) ... */
            let newIndex = currentQuestionIndex;
            if (direction === 'prev' && currentQuestionIndex > 0) {
                newIndex--;
            } else if (direction === 'next' && currentQuestionIndex < currentTestMCQs.length - 1) {
                newIndex++;
            }
            // Only update display if the index actually changed
            if (newIndex !== currentQuestionIndex) {
                displayTestQuestion(newIndex);
            }
        }
        function startTestTimer() { /* ... (same as before) ... */
            if (testTimerInterval) clearInterval(testTimerInterval); // Clear existing timer
            testStartTime = Date.now(); // Record start time
            testTimer.textContent = `Time: 00:00`; // Reset display
            // Update timer every second
            testTimerInterval = setInterval(() => {
                const elapsedSeconds = Math.floor((Date.now() - testStartTime) / 1000);
                const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0');
                const seconds = (elapsedSeconds % 60).toString().padStart(2, '0');
                testTimer.textContent = `Time: ${minutes}:${seconds}`;
            }, 1000);
        }
        function submitTest() { /* ... (same as before) ... */
            if (!confirm("Are you sure you want to submit the test? / சோதனையைச் சமர்ப்பிக்க உறுதியாக இருக்கிறீர்களா?")) return;

            if (testTimerInterval) clearInterval(testTimerInterval); // Stop the timer
            const endTime = Date.now();
            const timeTakenMs = testStartTime ? endTime - testStartTime : 0;
            console.log("Submitting test. Time taken (ms):", timeTakenMs);

            // Calculate results using the questions from the CURRENT test session
            const results = calculateResults(currentTestMCQs, userAnswers, timeTakenMs);
            reviewResultsCache = results; // Cache results for review display and potential saving

            // Switch to review view, indicating it's NOT from the "All Tests" list
            switchView('review', false);
            displayReview(results); // Display the results
        }

        // --- Review Functions ---

        // --- NEW Function: Toggle Review Language ---
        function toggleReviewLanguage() {
            currentReviewLanguage = (currentReviewLanguage === 'en') ? 'ta' : 'en'; // Switch language state
            reviewLanguageToggle.textContent = (currentReviewLanguage === 'en') ? 'தமிழ்' : 'English'; // Update button text
            // Re-display the review in the new language (using the cached data)
            if (reviewResultsCache) {
                displayReview(reviewResultsCache); // Re-render the review
            }
            console.log("Switched review language to:", currentReviewLanguage);
        }

        // MODIFIED calculateResults (Ensure originalMCQs included - already done)
        function calculateResults(mcqs, answers, timeMs) {
             let correctCount = 0, incorrectCount = 0, skippedCount = 0;
             const reviewQuestions = []; // Data specifically for displaying the review

             mcqs.forEach((qData, index) => {
                 // Safely access properties with fallbacks
                 const userAnswerIndex = answers[index]; // User's selected index (0-3) or null
                 const options = Array.isArray(qData.options) ? qData.options : [];
                 const correctAnswerLetter = qData.answer?.trim().toUpperCase(); // A, B, C, D
                 const correctAnswerIndex = correctAnswerLetter ? correctAnswerLetter.charCodeAt(0) - 'A'.charCodeAt(0) : -1; // 0-3 or -1

                 // Determine correct answer text (use English as primary fallback for summary)
                 const correctAnswerTextEn = (correctAnswerIndex >= 0 && correctAnswerIndex < options.length)
                                           ? (options[correctAnswerIndex]?.en || '(Missing Correct Option Text)') : "N/A";

                 let userAnswerTextEn = "Skipped"; // Default status text
                 let status = "skipped";

                 if (userAnswerIndex !== null && userAnswerIndex >= 0 && userAnswerIndex < options.length) {
                     // User selected a valid option index
                     userAnswerTextEn = options[userAnswerIndex]?.en || '(Missing User Option Text)'; // Get English text for the selected option
                     if (userAnswerIndex === correctAnswerIndex) {
                         status = "correct"; correctCount++;
                     } else {
                         status = "incorrect"; incorrectCount++;
                     }
                 } else if (userAnswerIndex !== null) {
                     // User selected something invalid (shouldn't happen with radio buttons)
                      userAnswerTextEn = "Invalid Selection"; status = "incorrect"; incorrectCount++;
                 } else {
                     // User didn't select anything (null)
                     skippedCount++;
                 }

                 // Store data needed *for review display*. Bilingual text comes from originalMCQs later.
                 reviewQuestions.push({
                     // Store English versions here for simpler structure, bilingual lookup happens in displayReview
                     question: qData.question?.en || '(Question missing)',
                     correctAnswer: correctAnswerTextEn,
                     userAnswer: userAnswerTextEn, // Store the English text of the user's answer or status
                     status: status,
                     explanation: qData.explanation?.en || "No explanation provided." // Store English explanation
                     // Note: We don't store the bilingual text *here* to avoid duplication.
                     // We rely on having originalMCQs available when displaying the review.
                 });
             });

             const totalQuestions = mcqs.length;
             const score = `${correctCount}/${totalQuestions}`;
             const timeSeconds = Math.round(timeMs / 1000);
             const minutes = Math.floor(timeSeconds / 60);
             const seconds = timeSeconds % 60;
             const timeString = `${minutes}m ${seconds}s`;

             return {
                 questions: reviewQuestions, // Review display summary data (mostly English)
                 summary: { score, correct: correctCount, incorrect: incorrectCount, skipped: skippedCount, timeString },
                 testDate: new Date().toISOString(),
                 timeTakenMs: timeMs,
                 sourceChatId: activeChatId,
                 testTitle: testTitle.textContent, // Title shown during THIS test
                 // *** CRUCIAL: Include the original MCQs with bilingual data ***
                 originalMCQs: mcqs
             };
        }

        // --- MODIFIED displayReview function (Bilingual & Explanation) ---
        function displayReview(reviewData) {
             reviewContent.innerHTML = ''; // Clear previous review items
             reviewSummary.innerHTML = ''; // Clear summary
             reviewFilters.style.display = 'none'; // Hide filters initially

             if (!reviewData || !reviewData.questions || reviewData.questions.length === 0 || !reviewData.summary || !reviewData.originalMCQs) { // Check for originalMCQs
                 reviewSummary.innerHTML = "<span>No valid review data available (might be missing original questions).</span>";
                 reviewContent.innerHTML = "<p>It seems the review data is missing or incomplete.</p>";
                 saveReviewBtn.style.display = 'none';
                 return;
             }

             // Reset review language to 'en' only if it's a fresh display (not a toggle)
             // Check if the button text reflects the current state. If not, reset.
             const expectedButtonText = (currentReviewLanguage === 'en') ? 'தமிழ்' : 'English';
             if (!reviewLanguageToggle || reviewLanguageToggle.textContent !== expectedButtonText) { // Add check for button existence
                  currentReviewLanguage = 'en'; // Default to English for new review display
                  if (reviewLanguageToggle) reviewLanguageToggle.textContent = 'தமிழ்'; // Update button if it exists
             }

             // Display Summary (language neutral)
             const { score, correct, incorrect, skipped, timeString } = reviewData.summary;
             reviewSummary.innerHTML = `
                  <span>Score: ${score}</span>
                  <span class="score-correct">Correct: ${correct}</span>
                  <span class="score-incorrect">Incorrect: ${incorrect}</span>
                  <span class="score-skipped">Skipped: ${skipped}</span>
                  <span>Total Time: ${timeString}</span>
             `;

             reviewTitle.textContent = reviewData.testTitle || "Test Review"; // Set title

             // Get language for display ('en' or 'ta')
             const lang = currentReviewLanguage;

             // Display Individual Questions using bilingual data
             reviewData.questions.forEach((qReviewSummary, index) => { // qReviewSummary has English texts + status
                 const originalQData = reviewData.originalMCQs[index]; // Get the full bilingual data

                 if (!originalQData) {
                     console.warn(`Original MCQ data missing for review item ${index}`);
                     // Fallback: Display basic info from qReviewSummary if original is missing
                     const reviewItem = document.createElement('div');
                     reviewItem.classList.add('review-item', `status-${qReviewSummary.status || 'unknown'}`);
                     reviewItem.innerHTML = `
                        <div class="review-item-qnum">Question ${index + 1}</div>
                        <div class="review-item-question">${qReviewSummary.question || '(Question missing)'}</div>
                        <div class="review-item-details">
                            <span>Your Answer: ${qReviewSummary.userAnswer || 'N/A'}</span><br>
                            <span class="correct-answer">Correct Answer: ${qReviewSummary.correctAnswer || 'N/A'}</span>
                            <div class="review-item-explanation">Explanation: ${qReviewSummary.explanation || 'N/A'}</div>
                        </div>`;
                     reviewContent.appendChild(reviewItem);
                     return; // Skip to next item
                 }

                 // *** Get bilingual text from originalQData, fallback to English ***
                 const questionText = originalQData.question?.[lang] || originalQData.question?.en || '(Question text missing)';

                 const options = originalQData.options || [];
                 const correctAnswerLetter = originalQData.answer?.trim().toUpperCase();
                 const correctAnswerIndex = correctAnswerLetter ? correctAnswerLetter.charCodeAt(0) - 'A'.charCodeAt(0) : -1;
                 // Get correct answer text in the selected language
                 const correctAnswerText = (correctAnswerIndex >= 0 && correctAnswerIndex < options.length)
                                            ? (options[correctAnswerIndex]?.[lang] || options[correctAnswerIndex]?.en) : "N/A";

                 // Determine user answer text in the selected language
                 let userAnswerText = qReviewSummary.userAnswer; // Start with the text stored in summary (might be "Skipped" or English option)
                 const status = qReviewSummary.status;
                 if (status !== 'skipped' && status !== 'invalid') {
                      // If user answered, try to find the corresponding option index from the English text
                      const userAnswerEn = qReviewSummary.userAnswer;
                      const userAnswerIndex = options.findIndex(opt => opt.en === userAnswerEn);
                      if (userAnswerIndex !== -1) {
                           // Found the option, get the text in the selected language
                           userAnswerText = options[userAnswerIndex]?.[lang] || options[userAnswerIndex]?.en;
                      } else {
                          // Couldn't match English text (maybe data mismatch?), fallback to stored English
                          userAnswerText = userAnswerEn || '(Answer text missing)';
                      }
                 } else if (status === 'skipped') {
                     // Explicitly set skipped text for different languages if desired
                     userAnswerText = (lang === 'ta') ? "தவிர்க்கப்பட்டது" : "Skipped";
                 } else { // Invalid
                     userAnswerText = (lang === 'ta') ? "தவறான தேர்வு" : "Invalid Selection";
                 }


                 // Get explanation in the selected language
                 const explanationText = originalQData.explanation?.[lang] || originalQData.explanation?.en || "No explanation provided.";

                 // --- Create Review Item Element ---
                 let itemStatusClass = `status-${status}`;
                 let answerDetailClass = `user-answer-${status}`;

                 const reviewItem = document.createElement('div');
                 reviewItem.classList.add('review-item', itemStatusClass);
                 reviewItem.dataset.status = status; // For filtering

                 // Build details HTML
                 let detailsHtml = `<span class="${answerDetailClass}">Your Answer: ${userAnswerText}</span>`;
                 if (status !== 'correct') { // Show correct answer if user was wrong or skipped
                     detailsHtml += `<br><span class="correct-answer">Correct Answer: ${correctAnswerText}</span>`;
                 }
                 // Add Explanation
                 detailsHtml += `<div class="review-item-explanation">${(lang === 'ta' ? 'விளக்கம்' : 'Explanation')}: ${explanationText}</div>`;

                 // Set innerHTML for the review item
                 reviewItem.innerHTML = `
                     <div class="review-item-qnum">Question ${index + 1}</div>
                     <div class="review-item-question">${questionText}</div>
                     <div class="review-item-details">${detailsHtml}</div>
                 `;
                 reviewContent.appendChild(reviewItem);
             });

             // Configure Save Button
             if (reviewData.savedAt) { // Loaded from saved reviews (already saved)
                 saveReviewBtn.textContent = "Review Saved";
                 saveReviewBtn.disabled = true;
                 saveReviewBtn.style.display = 'inline-block';
             } else if (reviewResultsCache && !cameFromAllTestsList) { // Fresh review from test just taken
                 saveReviewBtn.textContent = "Save Review";
                 saveReviewBtn.disabled = !currentUser; // Enable only if logged in
                 saveReviewBtn.style.display = 'inline-block';
             } else { // Hide if no cache or came from all tests list (already saved)
                  saveReviewBtn.style.display = 'none';
             }

             reviewFilters.style.display = 'block'; // Show filters

             // Re-render MathJax for review content
              try {
                  if (typeof MathJax !== "undefined" && MathJax.typesetPromise) {
                       MathJax.typesetPromise([reviewContent]).catch(err => console.error('MathJax typeset error on review:', err));
                  }
              } catch (e) { console.error("MathJax call failed:", e); }

             // Apply default filter ('all')
             filterReviewItems('all');
             // Ensure 'All' button is marked active
             reviewFilters.querySelectorAll('button').forEach(btn => {
                 btn.classList.toggle('active-filter', btn.dataset.filter === 'all');
             });
        } // End of displayReview

        function handleReviewFilterClick(event) { /* ... (same as before) ... */
            const button = event.target.closest('button[data-filter]');
            if (button) {
                filterReviewItems(button.dataset.filter);
            }
        }
        function filterReviewItems(filter) { /* ... (same as before) ... */
            // Highlight active filter button
            reviewFilters.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('active-filter', btn.dataset.filter === filter);
            });
            // Show/hide review items based on filter and status
            reviewContent.querySelectorAll('.review-item').forEach(item => {
                const show = (filter === 'all') || item.dataset.status === filter;
                item.classList.toggle('hidden-by-filter', !show); // Add/remove class to hide
            });
        }
        function exitReview() { /* ... (same as before) ... */
            reviewResultsCache = null; // Clear current review cache

            // Go back to chat view
            switchView('chat');

            // Reset review specific UI elements (optional, but good practice)
            reviewSummary.innerHTML = '';
            reviewContent.innerHTML = '';
            reviewTitle.textContent = 'Test Review';
            if (reviewLanguageToggle) reviewLanguageToggle.textContent = 'தமிழ்'; // Reset toggle text
            currentReviewLanguage = 'en'; // Reset language state
        }
        async function saveTestReviewToCloud() { /* ... (same as before - uses reviewResultsCache) ... */
            if (!currentUser) { alert("Please log in to save the review. / மதிப்பாய்வைச் சேமிக்க உள்நுழையவும்."); return; }
            // Use reviewResultsCache which holds the data from the just-completed test
            if (!reviewResultsCache || reviewResultsCache.savedAt) {
                 alert("No new review data available to save or it has already been saved. / சேமிக்க புதிய ஆய்வுத் தரவு இல்லை அல்லது அது ஏற்கனவே சேமிக்கப்பட்டுள்ளது.");
                 return;
             }
             // Check if originalMCQs exist (crucial for bilingual review later)
             if (!reviewResultsCache.originalMCQs || reviewResultsCache.originalMCQs.length === 0) {
                 if (!confirm("Warning: Original question data (including translations) seems missing. Review might not display correctly later. Save anyway?")) {
                      return;
                 }
             }


            // Prepare data, ensure necessary fields are included
            const reviewDataToSave = {
                ...reviewResultsCache, // Includes questions (summary), summary, testTitle, originalMCQs, etc.
                userId: currentUser.uid,
                savedAt: firebase.firestore.FieldValue.serverTimestamp(), // Add server timestamp on save
            };

            saveReviewBtn.disabled = true;
            saveReviewBtn.textContent = "Saving...";

            try {
                const newReviewRef = await db.collection('testReviews').add(reviewDataToSave);
                console.log("Review saved to Firestore with ID:", newReviewRef.id);
                alert("Test review saved successfully! / சோதனை ஆய்வு வெற்றிகரமாக சேமிக்கப்பட்டது!");
                saveReviewBtn.textContent = "Review Saved"; // Keep disabled after successful save
                // Mark cache as saved locally to prevent accidental resave attempts
                if (reviewResultsCache) reviewResultsCache.savedAt = new Date(); // Mark as saved

            } catch (error) {
                console.error("Error saving review to Firestore:", error);
                alert("Failed to save the review. Please check your connection and try again. / மதிப்பாய்வைச் சேமிக்கத் தவறிவிட்டது. உங்கள் இணைப்பைச் சரிபார்த்து மீண்டும் முயற்சிக்கவும்.");
                saveReviewBtn.disabled = false; // Re-enable on failure
                saveReviewBtn.textContent = "Save Review";
            }
        }

        // --- All Tests List Functions ---
        function loadAndListenForTests(userId) { /* ... (same as before) ... */
            if (testListListener) { testListListener(); testListListener = null; }

            const testsRef = db.collection('testReviews')
                                .where('userId', '==', userId)
                                .orderBy('savedAt', 'desc');

            console.log(`Listening for saved tests for user ${userId}`);
            testListListener = testsRef.onSnapshot(snapshot => {
                allSavedTestsData = []; // Clear local cache before filling
                snapshot.forEach(doc => {
                    allSavedTestsData.push({ id: doc.id, ...doc.data() });
                });
                console.log("Received saved tests snapshot:", allSavedTestsData.length, "tests");
                renderAllTestsList(allSavedTestsData); // Update UI
                filterTestsInSidebar(); // Apply existing search filter if any

            }, error => {
                console.error("Error listening for saved tests:", error);
                // Show error in the list area itself
                allTestsListContainer.innerHTML = `<div style="padding:10px;color:var(--error-text);font-size:0.9em;">Error loading tests. Check console (F12) & Firestore index/rules.</div>`;
                allSavedTestsData = []; // Clear cache on error
            });
        }

        // MODIFIED renderAllTestsList (Adds Edit/Delete buttons)
        function renderAllTestsList(tests) {
            allTestsListContainer.innerHTML = ''; // Clear previous list
            if (!currentUser) {
                allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div>';
                return;
            }
            if (tests.length === 0) {
                allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">No saved tests yet.</div>';
            } else {
                tests.forEach(testData => {
                    const itemElement = document.createElement('div');
                    itemElement.classList.add('test-list-item');
                    itemElement.dataset.reviewId = testData.id; // Store Firestore ID

                    const title = testData.testTitle || '(Untitled Test)';
                    // Format date safely
                    const date = testData.savedAt?.toDate ? testData.savedAt.toDate().toLocaleString() : 'Unknown date';
                    const score = testData.summary?.score || 'N/A';

                    // Check if reattempt is possible (requires valid originalMCQs)
                    const hasReattemptData = testData.originalMCQs && Array.isArray(testData.originalMCQs) && testData.originalMCQs.length > 0 &&
                                             // Basic check for structure needed for bilingual display
                                             testData.originalMCQs.every(q => q && q.question && q.options && q.answer && q.explanation);

                    // --- Info Div (Title, Details, Edit/Delete Controls) ---
                    const infoDiv = document.createElement('div');
                    infoDiv.classList.add('test-item-info'); // Enables relative positioning for controls

                    // Title Span
                    const titleSpan = document.createElement('span');
                    titleSpan.classList.add('test-item-title');
                    titleSpan.textContent = title;
                    titleSpan.title = title; // Tooltip for long titles

                    // Details Span
                    const detailsSpan = document.createElement('span');
                    detailsSpan.classList.add('test-item-details');
                    detailsSpan.textContent = `Saved: ${date} | Score: ${score}`;

                    // Controls Div (Edit/Delete)
                    const controlsDiv = document.createElement('div');
                    controlsDiv.classList.add('test-item-controls');

                    const editBtn = document.createElement('button');
                    editBtn.innerHTML = EDIT_TEST_ICON; // '✏️'
                    editBtn.title = "Edit test title";
                    editBtn.dataset.action = "edit-title"; // Action for click handler
                    controlsDiv.appendChild(editBtn);

                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = DELETE_TEST_ICON; // '🗑️'
                    deleteBtn.title = "Delete this saved test";
                    deleteBtn.dataset.action = "delete-test"; // Action for click handler
                    controlsDiv.appendChild(deleteBtn);

                    // Add title, details, and controls to infoDiv
                    infoDiv.appendChild(titleSpan);
                    infoDiv.appendChild(detailsSpan);
                    infoDiv.appendChild(controlsDiv);

                    // --- Actions Div (View Details, Reattempt) ---
                    const actionsDiv = document.createElement('div');
                    actionsDiv.classList.add('test-item-actions');

                    // View Details Button
                    const viewBtn = document.createElement('button');
                    viewBtn.textContent = "View Details";
                    viewBtn.dataset.action = "view"; // Action for click handler
                    actionsDiv.appendChild(viewBtn);

                    // Reattempt Select Dropdown
                    const reattemptSelect = document.createElement('select');
                    reattemptSelect.dataset.action = "reattempt";
                    reattemptSelect.disabled = !hasReattemptData;
                    reattemptSelect.title = hasReattemptData ? "Reattempt options" : "Reattempt not available (Missing original question data)";
                    // Options for reattempt modes
                    reattemptSelect.innerHTML = `
                        <option value="" selected>${hasReattemptData ? 'Reattempt...' : 'Reattempt N/A'}</option>
                        <option value="mistaked" ${!hasReattemptData ? 'disabled' : ''}>Mistaked Only</option>
                        <option value="skipped" ${!hasReattemptData ? 'disabled' : ''}>Skipped Only</option>
                        <option value="both" ${!hasReattemptData ? 'disabled' : ''}>Mistaked & Skipped</option>
                        <option value="full" ${!hasReattemptData ? 'disabled' : ''}>Full Test</option>
                    `;
                    // Add event listener directly to the select element
                    reattemptSelect.addEventListener('change', (event) => {
                        const selectedMode = event.target.value;
                        if (selectedMode) { // If a mode other than the placeholder is selected
                             const reviewId = event.target.closest('.test-list-item')?.dataset.reviewId;
                             if (reviewId) {
                                 startReattempt(reviewId, selectedMode); // Trigger reattempt
                             }
                             event.target.value = ""; // Reset select to placeholder after action
                        }
                    });
                    actionsDiv.appendChild(reattemptSelect);

                    // Append info and actions divs to the main item element
                    itemElement.appendChild(infoDiv);
                    itemElement.appendChild(actionsDiv);
                    allTestsListContainer.appendChild(itemElement); // Add item to the list
                });
            }
        }

        function filterTestsInSidebar() { /* ... (same as before) ... */
            const searchTerm = testSearchInput.value.toLowerCase().trim();
            const items = allTestsListContainer.querySelectorAll('.test-list-item');
            let visibleCount = 0;

            // Remove existing no-results message first
             const existingNoResultsMsg = allTestsListContainer.querySelector('.no-search-results');
             if (existingNoResultsMsg) {
                 existingNoResultsMsg.remove();
             }

            items.forEach(item => {
                // Check title and details for search term
                const titleElement = item.querySelector('.test-item-title');
                const detailsElement = item.querySelector('.test-item-details');
                const titleText = titleElement ? titleElement.textContent.toLowerCase() : '';
                const detailsText = detailsElement ? detailsElement.textContent.toLowerCase() : '';

                const isMatch = titleText.includes(searchTerm) || detailsText.includes(searchTerm);
                item.classList.toggle('hidden-by-search', !isMatch); // Hide if no match
                if (isMatch) {
                    visibleCount++;
                }
            });

             // Add "No results" message if needed AFTER filtering
             if (visibleCount === 0 && searchTerm !== '' && items.length > 0) {
                 const msgDiv = document.createElement('div');
                 msgDiv.textContent = "No tests match your search.";
                 msgDiv.classList.add('no-search-results'); // Use class for styling
                 allTestsListContainer.appendChild(msgDiv);
             }
        }

        // MODIFIED handleAllTestsListClick (Handles view, edit-title, delete-test)
        async function handleAllTestsListClick(event) {
            // Find the closest button with a data-action attribute
            const button = event.target.closest('button[data-action]');
            if (!button) return; // Exit if click wasn't on an action button

            const action = button.dataset.action;
            const listItem = button.closest('.test-list-item'); // Find the parent list item
            const reviewId = listItem?.dataset.reviewId; // Get the Firestore ID

            if (!reviewId) {
                console.warn("Action button clicked, but couldn't find review ID.");
                return;
            }

            // Handle different actions based on button's data-action
            switch (action) {
                case "view":
                    console.log("View Details clicked for review:", reviewId);
                    // Find data from the local cache populated by the listener
                    const reviewData = allSavedTestsData.find(test => test.id === reviewId);
                    if (reviewData) {
                        reviewResultsCache = reviewData; // Cache for display
                        switchView('review', true); // Switch view, indicate came from tests list
                        displayReview(reviewData); // Display this specific review
                    } else {
                        console.error("Could not find review data in cache for ID:", reviewId);
                        alert("Error: Could not load review details.");
                    }
                    break;

                case "edit-title":
                    console.log("Edit Title clicked for review:", reviewId);
                    enterTestTitleEditMode(listItem, reviewId); // Switch item to edit mode
                    break;

                case "delete-test":
                    console.log("Delete Test clicked for review:", reviewId);
                    const testTitleSpan = listItem.querySelector('.test-item-title');
                    const testTitle = testTitleSpan?.textContent || 'this test'; // Get title for confirm message
                    // Ask for confirmation before deleting
                    if (confirm(`Are you sure you want to permanently delete the saved test "${testTitle}"? This cannot be undone. / சேமிக்கப்பட்ட சோதனை "${testTitle}" ஐ நிரந்தரமாக நீக்க உறுதியாக இருக்கிறீர்களா? இது செயல்தவிர்க்க முடியாதது.`)) {
                        deleteSavedTest(reviewId, listItem); // Proceed with deletion
                    }
                    break;

                // Note: Reattempt logic is handled by its own 'change' listener on the select element
            }
        }

        // --- NEW Function: Enter Edit Mode for Test Title ---
        function enterTestTitleEditMode(listItem, reviewId) {
            const infoDiv = listItem.querySelector('.test-item-info');
            const titleSpan = infoDiv.querySelector('.test-item-title');
            const detailsSpan = infoDiv.querySelector('.test-item-details');
            const controlsDiv = infoDiv.querySelector('.test-item-controls'); // Edit/Delete icons
            const currentTitle = titleSpan.textContent;

            // Hide original title, details, and controls
            titleSpan.style.display = 'none';
            detailsSpan.style.display = 'none'; // Hide details during edit
            if(controlsDiv) controlsDiv.style.display = 'none';

            // Check if edit container already exists to prevent duplicates
            if (infoDiv.querySelector('.test-item-edit-mode')) return;

            // Create container for input and save/cancel buttons
            const editContainer = document.createElement('div');
            editContainer.classList.add('test-item-edit-mode');

            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentTitle;
            input.maxLength = 100; // Limit title length
            // Add keydown listener to save on Enter, cancel on Escape
            input.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter') {
                     saveTestTitle(listItem, reviewId, input.value);
                 } else if (e.key === 'Escape') {
                     exitTestTitleEditMode(listItem, currentTitle);
                 }
            });

            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.onclick = () => saveTestTitle(listItem, reviewId, input.value);

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => exitTestTitleEditMode(listItem, currentTitle); // Pass original title to restore on cancel

            editContainer.appendChild(input);
            editContainer.appendChild(saveBtn);
            editContainer.appendChild(cancelBtn);

            // Insert the edit container into the infoDiv
            infoDiv.appendChild(editContainer);
            input.focus(); // Focus the input field
            input.select(); // Select current text
        }

        // --- NEW Function: Exit Edit Mode ---
        function exitTestTitleEditMode(listItem, originalTitle = null) {
            const infoDiv = listItem.querySelector('.test-item-info');
            const titleSpan = infoDiv.querySelector('.test-item-title');
            const detailsSpan = infoDiv.querySelector('.test-item-details');
            const controlsDiv = infoDiv.querySelector('.test-item-controls');
            const editContainer = infoDiv.querySelector('.test-item-edit-mode');

            if (editContainer) {
                editContainer.remove(); // Remove input and buttons
            }

            // Restore original title if provided (used on cancel)
            if (originalTitle !== null && titleSpan) {
                 titleSpan.textContent = originalTitle;
                 titleSpan.title = originalTitle; // Update tooltip too
            }

            // Show original title, details, and controls again
            if(titleSpan) titleSpan.style.display = '';
            if(detailsSpan) detailsSpan.style.display = '';
            if(controlsDiv) controlsDiv.style.display = ''; // Use display flex if needed based on CSS
        }

        // --- NEW Function: Save Edited Test Title ---
        async function saveTestTitle(listItem, reviewId, newTitle) {
            const trimmedTitle = newTitle.trim();
            if (!trimmedTitle) {
                alert("Test title cannot be empty. / சோதனைத் தலைப்பு காலியாக இருக்க முடியாது.");
                return;
            }
            if (trimmedTitle.length > 100) {
                 alert("Test title is too long (max 100 characters). / சோதனைத் தலைப்பு மிக நீளமாக உள்ளது (அதிகபட்சம் 100 எழுத்துகள்).");
                 return;
            }

            const testDocRef = db.collection('testReviews').doc(reviewId);
            try {
                // Update only the testTitle field in Firestore
                await testDocRef.update({ testTitle: trimmedTitle });
                console.log("Test title updated successfully in Firestore:", reviewId, trimmedTitle);

                // Update UI immediately in the title span
                const titleSpan = listItem.querySelector('.test-item-title');
                if (titleSpan) {
                    titleSpan.textContent = trimmedTitle;
                    titleSpan.title = trimmedTitle; // Update tooltip
                }

                // Update local cache (allSavedTestsData) for consistency
                const testIndex = allSavedTestsData.findIndex(test => test.id === reviewId);
                if (testIndex > -1) {
                    allSavedTestsData[testIndex].testTitle = trimmedTitle;
                }

                exitTestTitleEditMode(listItem); // Exit edit mode on success

            } catch (error) {
                console.error("Error updating test title in Firestore:", error);
                alert("Failed to update the test title. Please try again. / சோதனைத் தலைப்பைப் புதுப்பிக்கத் தவறிவிட்டது. மீண்டும் முயற்சிக்கவும்.");
                // Optionally, exit edit mode even on error to avoid getting stuck
                // exitTestTitleEditMode(listItem, listItem.querySelector('.test-item-edit-mode input')?.value || null);
            }
        }

        // --- NEW Function: Delete Saved Test ---
        async function deleteSavedTest(reviewId, listItemElement) {
             if (!currentUser || !reviewId) return;

             // Visually indicate deletion process (optional)
             listItemElement.style.opacity = '0.5';
             listItemElement.style.pointerEvents = 'none'; // Disable clicks during delete

             const testDocRef = db.collection('testReviews').doc(reviewId);
             try {
                 await testDocRef.delete(); // Delete the document from Firestore
                 console.log("Saved test deleted successfully from Firestore:", reviewId);
                 // The list will auto-update via the Firestore listener (renderAllTestsList)
                 // No need to manually remove listItemElement if listener works reliably.
                 // If immediate removal is desired (though may cause flicker with listener):
                 // listItemElement.remove();

                 // Update local cache immediately for responsiveness
                 allSavedTestsData = allSavedTestsData.filter(test => test.id !== reviewId);
                 // Optionally re-apply filter if search is active
                 // filterTestsInSidebar();

                 alert("Saved test deleted. / சேமித்த சோதனை நீக்கப்பட்டது.");


             } catch (error) {
                 console.error("Error deleting saved test from Firestore:", error);
                 alert("Failed to delete the saved test. Please try again. / சேமித்த சோதனையை நீக்கத் தவறிவிட்டது. மீண்டும் முயற்சிக்கவும்.");
                 // Restore appearance on error
                 listItemElement.style.opacity = '1';
                 listItemElement.style.pointerEvents = 'auto';
             }
        }

        // MODIFIED startReattempt (Handles bilingual implicitly)
        async function startReattempt(reviewId, mode) {
            console.log(`Starting reattempt for review: ${reviewId}, mode: ${mode}`);

            // Find the full review data (including originalMCQs) from cache
            const reviewData = allSavedTestsData.find(test => test.id === reviewId);

            if (!reviewData) {
                alert("Error: Could not find the data for this test review. / பிழை: இந்த சோதனை ஆய்வுக்கான தரவைக் கண்டுபிடிக்க முடியவில்லை.");
                return;
            }

            // Check again for valid originalMCQs data (crucial for reattempt)
            const originalMCQs = reviewData.originalMCQs;
            const hasValidReattemptData = originalMCQs && Array.isArray(originalMCQs) && originalMCQs.length > 0 &&
                                       originalMCQs.every(q => q && q.question && q.options && q.answer && q.explanation); // Check essential fields

            if (!hasValidReattemptData) {
                 alert("Error: Cannot reattempt this test because the original question data is missing or invalid (likely saved before this feature or has structure issues). / பிழை: அசல் கேள்வித் தரவு காணவில்லை அல்லது தவறானது என்பதால் இந்தச் சோதனையை மீண்டும் செய்ய முடியாது.");
                 return;
            }

            // Use the review summary data (qReview.status) to filter originalMCQs
            const reviewQuestionsSummary = reviewData.questions || [];
            let questionsToReattempt = [];

            switch (mode) {
                case 'mistaked':
                    questionsToReattempt = originalMCQs.filter((mcq, index) => reviewQuestionsSummary[index]?.status === 'incorrect');
                    break;
                case 'skipped':
                    questionsToReattempt = originalMCQs.filter((mcq, index) => reviewQuestionsSummary[index]?.status === 'skipped');
                    break;
                case 'both':
                    questionsToReattempt = originalMCQs.filter((mcq, index) => reviewQuestionsSummary[index]?.status === 'incorrect' || reviewQuestionsSummary[index]?.status === 'skipped');
                    break;
                case 'full':
                default:
                    questionsToReattempt = [...originalMCQs]; // Use a copy
                    break;
            }

            if (questionsToReattempt.length === 0) {
                alert(`No questions found for the selected reattempt mode ('${mode}'). / தேர்ந்தெடுக்கப்பட்ட மறுமுயற்சி முறைக்கு ('${mode}') கேள்விகள் எதுவும் இல்லை.`);
                return;
            }

            // Create a title for the reattempt session
            const reattemptTitle = `${reviewData.testTitle || 'Test'} (Reattempt: ${mode})`;

            // Start the test with the filtered questions
            // startMockTest handles switching view and setting up the test environment
            startMockTest(questionsToReattempt, reattemptTitle);
        }

    </script>

</body>
</html>
